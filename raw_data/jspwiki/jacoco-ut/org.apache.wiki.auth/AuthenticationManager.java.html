<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AuthenticationManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache JSPWiki Main Jar</a> &gt; <a href="index.source.html" class="el_package">org.apache.wiki.auth</a> &gt; <span class="el_source">AuthenticationManager.java</span></div><h1>AuthenticationManager.java</h1><pre class="source lang-java linenums">/*
    Licensed to the Apache Software Foundation (ASF) under one
    or more contributor license agreements.  See the NOTICE file
    distributed with this work for additional information
    regarding copyright ownership.  The ASF licenses this file
    to you under the Apache License, Version 2.0 (the
    &quot;License&quot;); you may not use this file except in compliance
    with the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing,
    software distributed under the License is distributed on an
    &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, either express or implied.  See the License for the
    specific language governing permissions and limitations
    under the License.    
 */
package org.apache.wiki.auth;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.Principal;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

import javax.security.auth.Subject;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.login.LoginException;
import javax.security.auth.spi.LoginModule;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;

import org.apache.commons.io.IOUtils;
import org.apache.log4j.Logger;
import org.apache.wiki.WikiEngine;
import org.apache.wiki.WikiSession;
import org.apache.wiki.api.exceptions.WikiException;
import org.apache.wiki.auth.authorize.Role;
import org.apache.wiki.auth.authorize.WebAuthorizer;
import org.apache.wiki.auth.authorize.WebContainerAuthorizer;
import org.apache.wiki.auth.login.AnonymousLoginModule;
import org.apache.wiki.auth.login.CookieAssertionLoginModule;
import org.apache.wiki.auth.login.CookieAuthenticationLoginModule;
import org.apache.wiki.auth.login.UserDatabaseLoginModule;
import org.apache.wiki.auth.login.WebContainerCallbackHandler;
import org.apache.wiki.auth.login.WebContainerLoginModule;
import org.apache.wiki.auth.login.WikiCallbackHandler;
import org.apache.wiki.event.WikiEventListener;
import org.apache.wiki.event.WikiEventManager;
import org.apache.wiki.event.WikiSecurityEvent;
import org.apache.wiki.util.TextUtil;
import org.apache.wiki.util.TimedCounterList;

/**
 * Manages authentication activities for a WikiEngine: user login, logout, and
 * credential refreshes. This class uses JAAS to determine how users log in.
 * &lt;p&gt;
 * The login procedure is protected in addition by a mechanism which prevents
 * a hacker to try and force-guess passwords by slowing down attempts to log in
 * into the same account.  Every login attempt is recorded, and stored for a while
 * (currently ten minutes), and each login attempt during that time incurs a penalty
 * of 2^login attempts milliseconds - that is, 10 login attempts incur a login penalty of 1.024 seconds.
 * The delay is currently capped to 20 seconds.
 * 
 * @since 2.3
 */
<span class="fc" id="L78">public class AuthenticationManager {</span>

    /** How many milliseconds the logins are stored before they're cleaned away. */
    private static final long LASTLOGINS_CLEANUP_TIME = 10*60*1000L; // Ten minutes

    private static final long MAX_LOGIN_DELAY         = 20*1000L; // 20 seconds
    
    /** The name of the built-in cookie assertion module */
<span class="fc" id="L86">    public static final String                 COOKIE_MODULE       =  CookieAssertionLoginModule.class.getName();</span>

    /** The name of the built-in cookie authentication module */
<span class="fc" id="L89">    public static final String                 COOKIE_AUTHENTICATION_MODULE =  CookieAuthenticationLoginModule.class.getName();</span>

    /** If this jspwiki.properties property is &lt;code&gt;true&lt;/code&gt;, logs the IP address of the editor on saving. */
    public static final String                 PROP_STOREIPADDRESS = &quot;jspwiki.storeIPAddress&quot;;
    
    /** If this jspwiki.properties property is &lt;code&gt;true&lt;/code&gt;, allow cookies to be used for authentication. */
    public static final String                 PROP_ALLOW_COOKIE_AUTH = &quot;jspwiki.cookieAuthentication&quot;;
    
    /**
     *  This property determines whether we use JSPWiki authentication or not.
     *  Possible values are AUTH_JAAS or AUTH_CONTAINER.
     *  &lt;p&gt;
     *  Setting this is now deprecated - we do not guarantee that it works.
     *  
     * @deprecated - to be removed on 2.11.0
     */
    @Deprecated
    public  static final String                PROP_SECURITY       = &quot;jspwiki.security&quot;;

    /** Value specifying that the user wants to use the container-managed security, just like in JSPWiki 2.2.
     * @deprecated - to be removed on 2.11.0
      */
    @Deprecated
    public static final String                SECURITY_OFF      = &quot;off&quot;;

    /** Value specifying that the user wants to use the built-in JAAS-based system.
     * @deprecated - to be removed on 2.11.0
     */
    @Deprecated
    public static final String                SECURITY_JAAS     = &quot;jaas&quot;;

    /** Whether logins should be throttled to limit brute-forcing attempts. Defaults to true. */
    public static final String                 PROP_LOGIN_THROTTLING = &quot;jspwiki.login.throttling&quot;;

<span class="fc" id="L123">    protected static final Logger              log                 = Logger.getLogger( AuthenticationManager.class );</span>

    /** Prefix for LoginModule options key/value pairs. */
    protected static final String                 PREFIX_LOGIN_MODULE_OPTIONS = &quot;jspwiki.loginModule.options.&quot;;

    /** If this jspwiki.properties property is &lt;code&gt;true&lt;/code&gt;, allow cookies to be used to assert identities. */
    protected static final String                 PROP_ALLOW_COOKIE_ASSERTIONS = &quot;jspwiki.cookieAssertions&quot;;

    /** The {@link javax.security.auth.spi.LoginModule} to use for custom authentication. */
    protected static final String                 PROP_LOGIN_MODULE = &quot;jspwiki.loginModule.class&quot;;
    
    /** Empty Map passed to JAAS {@link #doJAASLogin(Class, CallbackHandler, Map)} method. */
<span class="fc" id="L135">    protected static final Map&lt;String,String&gt; EMPTY_MAP = Collections.unmodifiableMap( new HashMap&lt;String,String&gt;() );</span>
    
    /** Class (of type LoginModule) to use for custom authentication. */
<span class="fc" id="L138">    protected Class&lt;? extends LoginModule&gt; m_loginModuleClass = UserDatabaseLoginModule.class;</span>
    
    /** Options passed to {@link javax.security.auth.spi.LoginModule#initialize(Subject, CallbackHandler, Map, Map)}; 
     * initialized by {@link #initialize(WikiEngine, Properties)}. */
<span class="fc" id="L142">    protected Map&lt;String,String&gt; m_loginModuleOptions = new HashMap&lt;String,String&gt;();</span>

    /** Just to provide compatibility with the old versions.  The same
     *  as SECURITY_OFF.
     *
     *  @deprecated use {@link #SECURITY_OFF} instead - to be removed on 2.11.0
     */
    @Deprecated
    protected static final String             SECURITY_CONTAINER = &quot;container&quot;;

    /** The default {@link javax.security.auth.spi.LoginModule} class name to use for custom authentication. */
    private static final String                 DEFAULT_LOGIN_MODULE = &quot;org.apache.wiki.auth.login.UserDatabaseLoginModule&quot;;
    
    /** Empty principal set. */
<span class="fc" id="L156">    private static final Set&lt;Principal&gt; NO_PRINCIPALS = new HashSet&lt;Principal&gt;();</span>

    /** Static Boolean for lazily-initializing the &quot;allows assertions&quot; flag */
<span class="fc" id="L159">    private boolean                     m_allowsCookieAssertions  = true;</span>

<span class="fc" id="L161">    private boolean                     m_throttleLogins = true;</span>

    /** Static Boolean for lazily-initializing the &quot;allows cookie authentication&quot; flag */
<span class="fc" id="L164">    private boolean                     m_allowsCookieAuthentication = false;</span>

<span class="fc" id="L166">    private WikiEngine                         m_engine            = null;</span>
    
    /** If true, logs the IP address of the editor */
<span class="fc" id="L169">    private boolean                            m_storeIPAddress    = true;</span>

    /** Keeps a list of the usernames who have attempted a login recently. */
<span class="fc" id="L172">    private TimedCounterList&lt;String&gt; m_lastLoginAttempts = new TimedCounterList&lt;String&gt;();</span>
    
    /**
     * Creates an AuthenticationManager instance for the given WikiEngine and
     * the specified set of properties. All initialization for the modules is
     * done here.
     * @param engine the wiki engine
     * @param props the properties used to initialize the wiki engine
     * @throws WikiException if the AuthenticationManager cannot be initialized
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public void initialize( WikiEngine engine, Properties props ) throws WikiException
    {
<span class="fc" id="L185">        m_engine = engine;</span>
<span class="fc" id="L186">        m_storeIPAddress = TextUtil.getBooleanProperty( props, PROP_STOREIPADDRESS, m_storeIPAddress );</span>

        // Should we allow cookies for assertions? (default: yes)
<span class="fc" id="L189">        m_allowsCookieAssertions = TextUtil.getBooleanProperty( props,</span>
                                                              PROP_ALLOW_COOKIE_ASSERTIONS,
                                                              true );
        
        // Should we allow cookies for authentication? (default: no)
<span class="fc" id="L194">        m_allowsCookieAuthentication = TextUtil.getBooleanProperty( props,</span>
                                                                    PROP_ALLOW_COOKIE_AUTH,
                                                                    false );
        
        // Should we throttle logins? (default: yes)
<span class="fc" id="L199">        m_throttleLogins = TextUtil.getBooleanProperty( props,</span>
                                                        PROP_LOGIN_THROTTLING,
                                                        true );

        // Look up the LoginModule class
<span class="fc" id="L204">        String loginModuleClassName = TextUtil.getStringProperty( props, PROP_LOGIN_MODULE, DEFAULT_LOGIN_MODULE );</span>
        try
        {
<span class="fc" id="L207">            m_loginModuleClass = (Class&lt;? extends LoginModule&gt;) Class.forName( loginModuleClassName );</span>
        }
<span class="nc" id="L209">        catch (ClassNotFoundException e)</span>
        {
<span class="nc" id="L211">            e.printStackTrace();</span>
<span class="nc" id="L212">            throw new WikiException( &quot;Could not instantiate LoginModule class.&quot;, e );</span>
<span class="fc" id="L213">        }</span>
        
        // Initialize the LoginModule options
<span class="fc" id="L216">        initLoginModuleOptions( props );</span>
<span class="fc" id="L217">    }</span>

    /**
     * Returns true if this WikiEngine uses container-managed authentication.
     * This method is used primarily for cosmetic purposes in the JSP tier, and
     * performs no meaningful security function per se. Delegates to
     * {@link org.apache.wiki.auth.authorize.WebContainerAuthorizer#isContainerAuthorized()},
     * if used as the external authorizer; otherwise, returns &lt;code&gt;false&lt;/code&gt;.
     * @return &lt;code&gt;true&lt;/code&gt; if the wiki's authentication is managed by
     *         the container, &lt;code&gt;false&lt;/code&gt; otherwise
     */
    public boolean isContainerAuthenticated()
    {
        try
        {
<span class="fc" id="L232">            Authorizer authorizer = m_engine.getAuthorizationManager().getAuthorizer();</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">            if ( authorizer instanceof WebContainerAuthorizer )</span>
            {
<span class="nc" id="L235">                 return ( ( WebContainerAuthorizer )authorizer ).isContainerAuthorized();</span>
            }
        }
<span class="nc" id="L238">        catch ( WikiException e )</span>
        {
            // It's probably ok to fail silently...
<span class="fc" id="L241">        }</span>
<span class="fc" id="L242">        return false;</span>
    }

    /**
     * &lt;p&gt;Logs in the user by attempting to populate a WikiSession Subject from
     * a web servlet request by examining the request
     *  for the presence of container credentials and user cookies. The processing
     * logic is as follows:
     * &lt;/p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;If the WikiSession had previously been unauthenticated, check to see if
     * user has subsequently authenticated. To be considered &quot;authenticated,&quot;
     * the request must supply one of the following (in order of preference):
     * the container &lt;code&gt;userPrincipal&lt;/code&gt;, container &lt;code&gt;remoteUser&lt;/code&gt;,
     * or authentication cookie. If the user is authenticated, this method fires event
     * {@link org.apache.wiki.event.WikiSecurityEvent#LOGIN_AUTHENTICATED}
     * with two parameters: a Principal representing the login principal,
     * and the current WikiSession. In addition, if the authorizer is of type
     * WebContainerAuthorizer, this method iterates through the container roles returned by
     * {@link org.apache.wiki.auth.authorize.WebContainerAuthorizer#getRoles()},
     * tests for membership in each one, and adds those that pass to the Subject's principal set.&lt;/li&gt;
     * &lt;li&gt;If, after checking for authentication, the WikiSession is still Anonymous,
     * this method next checks to see if the user has &quot;asserted&quot; an identity
     * by supplying an assertion cookie. If the user is found to be asserted,
     * this method fires event {@link org.apache.wiki.event.WikiSecurityEvent#LOGIN_ASSERTED}
     * with two parameters: &lt;code&gt;WikiPrincipal(&lt;em&gt;cookievalue&lt;/em&gt;)&lt;/code&gt;, and
     * the current WikiSession.&lt;/li&gt;
     * &lt;li&gt;If, after checking for authenticated and asserted status, the  WikiSession is
     * &lt;em&gt;still&lt;/em&gt; anonymous, this method fires event
     * {@link org.apache.wiki.event.WikiSecurityEvent#LOGIN_ANONYMOUS} with
     * two parameters: &lt;code&gt;WikiPrincipal(&lt;em&gt;remoteAddress&lt;/em&gt;)&lt;/code&gt;,
     * and the current WikiSession &lt;/li&gt;
     * &lt;/ul&gt;
     * @param request servlet request for this user
     * @return always returns &lt;code&gt;true&lt;/code&gt; (because anonymous login, at least, will always succeed)
     * @throws org.apache.wiki.auth.WikiSecurityException if the user cannot be logged in for any reason
     * @since 2.3
     */
    public boolean login( HttpServletRequest request ) throws WikiSecurityException
    {
<span class="fc" id="L282">        HttpSession httpSession = request.getSession();</span>
<span class="fc" id="L283">        WikiSession session = SessionMonitor.getInstance(m_engine).find( httpSession );</span>
<span class="fc" id="L284">        AuthenticationManager authenticationMgr = m_engine.getAuthenticationManager();</span>
<span class="fc" id="L285">        AuthorizationManager authorizationMgr = m_engine.getAuthorizationManager();</span>
<span class="fc" id="L286">        CallbackHandler handler = null;</span>
<span class="fc" id="L287">        Map&lt;String,String&gt; options = EMPTY_MAP;</span>

        // If user not authenticated, check if container logged them in, or if
        // there's an authentication cookie
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">        if ( !session.isAuthenticated() )</span>
        {
            // Create a callback handler
<span class="fc" id="L294">            handler = new WebContainerCallbackHandler( m_engine, request );</span>
            
            // Execute the container login module, then (if that fails) the cookie auth module
<span class="fc" id="L297">            Set&lt;Principal&gt; principals = authenticationMgr.doJAASLogin( WebContainerLoginModule.class, handler, options );</span>
<span class="fc bfc" id="L298" title="All 4 branches covered.">            if ( principals.size() == 0 &amp;&amp; authenticationMgr.allowsCookieAuthentication() )</span>
            {
<span class="fc" id="L300">                principals = authenticationMgr.doJAASLogin( CookieAuthenticationLoginModule.class, handler, options );</span>
            }
            
            // If the container logged the user in successfully, tell the WikiSession (and add all of the Principals)
<span class="fc bfc" id="L304" title="All 2 branches covered.">            if ( principals.size() &gt; 0 )</span>
            {
<span class="fc" id="L306">                fireEvent( WikiSecurityEvent.LOGIN_AUTHENTICATED, getLoginPrincipal( principals ), session );</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">                for ( Principal principal : principals )</span>
                {
<span class="fc" id="L309">                    fireEvent( WikiSecurityEvent.PRINCIPAL_ADD, principal, session );</span>
<span class="fc" id="L310">                }</span>
                
                // Add all appropriate Authorizer roles
<span class="fc" id="L313">                injectAuthorizerRoles( session, authorizationMgr.getAuthorizer(), request );</span>
            }
        }

        // If user still not authenticated, check if assertion cookie was supplied
<span class="pc bpc" id="L318" title="1 of 4 branches missed.">        if ( !session.isAuthenticated() &amp;&amp; authenticationMgr.allowsCookieAssertions() )</span>
        {
            // Execute the cookie assertion login module
<span class="fc" id="L321">            Set&lt;Principal&gt; principals = authenticationMgr.doJAASLogin( CookieAssertionLoginModule.class, handler, options );</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">            if ( principals.size() &gt; 0 )</span>
            {
<span class="fc" id="L324">                fireEvent( WikiSecurityEvent.LOGIN_ASSERTED, getLoginPrincipal( principals ), session);</span>
            }
        }

        // If user still anonymous, use the remote address
<span class="fc bfc" id="L329" title="All 2 branches covered.">        if (session.isAnonymous() )</span>
        {
<span class="fc" id="L331">            Set&lt;Principal&gt; principals = authenticationMgr.doJAASLogin( AnonymousLoginModule.class, handler, options );</span>
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">            if ( principals.size() &gt; 0 )</span>
            {
<span class="fc" id="L334">                fireEvent( WikiSecurityEvent.LOGIN_ANONYMOUS, getLoginPrincipal( principals ), session );</span>
<span class="fc" id="L335">                return true;</span>
            }
        }
        
        // If by some unusual turn of events the Anonymous login module doesn't work, login failed!
<span class="fc" id="L340">        return false;</span>
    }
    
    /**
     * Attempts to perform a WikiSession login for the given username/password
     * combination using JSPWiki's custom authentication mode. This method is identical to
     * {@link #login(WikiSession, String, String)}, except that user's HTTP request is not made available
     * to LoginModules via the {@link org.apache.wiki.auth.login.HttpRequestCallback}.
     * @param session the current wiki session; may not be &lt;code&gt;null&lt;/code&gt;.
     * @param username The user name. This is a login name, not a WikiName. In
     *            most cases they are the same, but in some cases, they might
     *            not be.
     * @param password the password
     * @return true, if the username/password is valid
     * @throws org.apache.wiki.auth.WikiSecurityException if the Authorizer or UserManager cannot be obtained
     * @deprecated use {@link #login(WikiSession, HttpServletRequest, String, String)} instead
     */
    public boolean login( WikiSession session, String username, String password ) throws WikiSecurityException
    {
<span class="nc" id="L359">        return login( session, null, username, password );</span>
    }
    
    /**
     * Attempts to perform a WikiSession login for the given username/password
     * combination using JSPWiki's custom authentication mode. In order to log in,
     * the JAAS LoginModule supplied by the WikiEngine property {@link #PROP_LOGIN_MODULE}
     * will be instantiated, and its
     * {@link javax.security.auth.spi.LoginModule#initialize(Subject, CallbackHandler, Map, Map)}
     * method will be invoked. By default, the {@link org.apache.wiki.auth.login.UserDatabaseLoginModule}
     * class will be used. When the LoginModule's &lt;code&gt;initialize&lt;/code&gt; method is invoked,
     * an options Map populated by properties keys prefixed by {@link #PREFIX_LOGIN_MODULE_OPTIONS}
     * will be passed as a parameter.
     * @param session the current wiki session; may not be &lt;code&gt;null&lt;/code&gt;.
     * @param request the user's HTTP request. This parameter may be &lt;code&gt;null&lt;/code&gt;, but the configured
     * LoginModule will not have access to the HTTP request in this case.
     * @param username The user name. This is a login name, not a WikiName. In
     *            most cases they are the same, but in some cases, they might
     *            not be.
     * @param password the password
     * @return true, if the username/password is valid
     * @throws org.apache.wiki.auth.WikiSecurityException if the Authorizer or UserManager cannot be obtained
     */
    public boolean login( WikiSession session, HttpServletRequest request, String username, String password ) throws WikiSecurityException
    {
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">        if ( session == null )</span>
        {
<span class="nc" id="L386">            log.error( &quot;No wiki session provided, cannot log in.&quot; );</span>
<span class="nc" id="L387">            return false;</span>
        }

        // Protect against brute-force password guessing if configured to do so
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">        if ( m_throttleLogins )</span>
        {
<span class="nc" id="L393">            delayLogin(username);</span>
        }
        
<span class="fc" id="L396">        CallbackHandler handler = new WikiCallbackHandler(</span>
                m_engine,
                null,
                username,
                password );
        
        // Execute the user's specified login module
<span class="fc" id="L403">        Set&lt;Principal&gt; principals = doJAASLogin( m_loginModuleClass, handler, m_loginModuleOptions );</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">        if (principals.size() &gt; 0)</span>
        {
<span class="fc" id="L406">            fireEvent(WikiSecurityEvent.LOGIN_AUTHENTICATED, getLoginPrincipal( principals ), session );</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">            for ( Principal principal : principals )</span>
            {
<span class="fc" id="L409">                fireEvent( WikiSecurityEvent.PRINCIPAL_ADD, principal, session );</span>
<span class="fc" id="L410">            }</span>
            
            // Add all appropriate Authorizer roles
<span class="fc" id="L413">            injectAuthorizerRoles( session, m_engine.getAuthorizationManager().getAuthorizer(), null );</span>
            
<span class="fc" id="L415">            return true;</span>
        }
<span class="fc" id="L417">        return false;</span>
    }
    
    /**
     *  This method builds a database of login names that are being attempted, and will try to
     *  delay if there are too many requests coming in for the same username.
     *  &lt;p&gt;
     *  The current algorithm uses 2^loginattempts as the delay in milliseconds, i.e.
     *  at 10 login attempts it'll add 1.024 seconds to the login.
     *  
     *  @param username The username that is being logged in
     */
    private void delayLogin( String username )
    {
        try
        {
<span class="nc" id="L433">            m_lastLoginAttempts.cleanup( LASTLOGINS_CLEANUP_TIME );</span>
<span class="nc" id="L434">            int count = m_lastLoginAttempts.count( username );</span>
            
<span class="nc" id="L436">            long delay = Math.min( 1&lt;&lt;count, MAX_LOGIN_DELAY );</span>
<span class="nc" id="L437">            log.debug( &quot;Sleeping for &quot;+delay+&quot; ms to allow login.&quot; );</span>
<span class="nc" id="L438">            Thread.sleep( delay );</span>
            
<span class="nc" id="L440">            m_lastLoginAttempts.add( username );</span>
        }
<span class="nc" id="L442">        catch( InterruptedException e )</span>
        {
            // FALLTHROUGH is fine
<span class="nc" id="L445">        }</span>
<span class="nc" id="L446">    }</span>

    /**
     * Logs the user out by retrieving the WikiSession associated with the
     * HttpServletRequest and unbinding all of the Subject's Principals,
     * except for {@link Role#ALL}, {@link Role#ANONYMOUS}.
     * is a cheap-and-cheerful way to do it without invoking JAAS LoginModules.
     * The logout operation will also flush the JSESSIONID cookie from
     * the user's browser session, if it was set.
     * @param request the current HTTP request
     */
    public void logout( HttpServletRequest request )
    {
<span class="nc bnc" id="L459" title="All 2 branches missed.">        if( request == null )</span>
        {
<span class="nc" id="L461">            log.error( &quot;No HTTP reqest provided; cannot log out.&quot; );</span>
<span class="nc" id="L462">            return;</span>
        }

<span class="nc" id="L465">        HttpSession session = request.getSession();</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">        String sid = ( session == null ) ? &quot;(null)&quot; : session.getId();</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">        if( log.isDebugEnabled() )</span>
        {
<span class="nc" id="L469">            log.debug( &quot;Invalidating WikiSession for session ID=&quot; + sid );</span>
        }
        // Retrieve the associated WikiSession and clear the Principal set
<span class="nc" id="L472">        WikiSession wikiSession = WikiSession.getWikiSession( m_engine, request );</span>
<span class="nc" id="L473">        Principal originalPrincipal = wikiSession.getLoginPrincipal();</span>
<span class="nc" id="L474">        wikiSession.invalidate();</span>

        // Remove the wikiSession from the WikiSession cache
<span class="nc" id="L477">        WikiSession.removeWikiSession( m_engine, request );</span>

        // We need to flush the HTTP session too
<span class="nc bnc" id="L480" title="All 2 branches missed.">        if ( session != null )</span>
        {
<span class="nc" id="L482">            session.invalidate();</span>
        }

        // Log the event
<span class="nc" id="L486">        fireEvent( WikiSecurityEvent.LOGOUT, originalPrincipal, null );</span>
<span class="nc" id="L487">    }</span>

    /**
     * Determines whether this WikiEngine allows users to assert identities using
     * cookies instead of passwords. This is determined by inspecting
     * the WikiEngine property {@link #PROP_ALLOW_COOKIE_ASSERTIONS}.
     * @return &lt;code&gt;true&lt;/code&gt; if cookies are allowed
     */
    public boolean allowsCookieAssertions()
    {
<span class="fc" id="L497">        return m_allowsCookieAssertions;</span>
    }

    /**
     *  Determines whether this WikiEngine allows users to authenticate using
     *  cookies instead of passwords. This is determined by inspecting
     * the WikiEngine property {@link #PROP_ALLOW_COOKIE_AUTH}.
     *  @return &lt;code&gt;true&lt;/code&gt; if cookies are allowed for authentication
     *  @since 2.5.62
     */
    public boolean allowsCookieAuthentication()
    {
<span class="fc" id="L509">        return m_allowsCookieAuthentication;</span>
    }
    
    /**
     * Determines whether the supplied Principal is a &quot;role principal&quot;.
     * @param principal the principal to test
     * @return &lt;code&gt;true&lt;/code&gt; if the Principal is of type
     *         {@link GroupPrincipal} or
     *         {@link org.apache.wiki.auth.authorize.Role},
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     */
    public static boolean isRolePrincipal( Principal principal )
    {
<span class="fc bfc" id="L522" title="All 4 branches covered.">        return principal instanceof Role || principal instanceof GroupPrincipal;</span>
    }

    /**
     * Determines whether the supplied Principal is a &quot;user principal&quot;.
     * @param principal the principal to test
     * @return &lt;code&gt;false&lt;/code&gt; if the Principal is of type
     *         {@link GroupPrincipal} or
     *         {@link org.apache.wiki.auth.authorize.Role},
     *         &lt;code&gt;true&lt;/code&gt; otherwise
     */
    public static boolean isUserPrincipal( Principal principal )
    {
<span class="fc bfc" id="L535" title="All 2 branches covered.">        return !isRolePrincipal( principal );</span>
    }

    /**
     * Instantiates and executes a single JAAS
     * {@link javax.security.auth.spi.LoginModule}, and returns a Set of
     * Principals that results from a successful login. The LoginModule is instantiated,
     * then its {@link javax.security.auth.spi.LoginModule#initialize(Subject, CallbackHandler, Map, Map)}
     * method is called. The parameters passed to &lt;code&gt;initialize&lt;/code&gt; is a 
     * dummy Subject, an empty shared-state Map, and an options Map the caller supplies.
     * 
     * @param clazz
     *            the LoginModule class to instantiate
     * @param handler
     *            the callback handler to supply to the LoginModule
     * @param options
     *            a Map of key/value strings for initializing the LoginModule
     * @return the set of Principals returned by the JAAS method {@link Subject#getPrincipals()}
     * @throws WikiSecurityException
     *             if the LoginModule could not be instantiated for any reason
     */
    protected Set&lt;Principal&gt; doJAASLogin(Class&lt;? extends LoginModule&gt; clazz, CallbackHandler handler, Map&lt;String,String&gt; options) throws WikiSecurityException
    {
        // Instantiate the login module
<span class="fc" id="L559">        LoginModule loginModule = null;</span>
        try
        {
<span class="fc" id="L562">            loginModule = clazz.newInstance();</span>
        }
<span class="nc" id="L564">        catch (InstantiationException e)</span>
        {
<span class="nc" id="L566">            throw new WikiSecurityException(e.getMessage(), e );</span>
        }
<span class="nc" id="L568">        catch (IllegalAccessException e)</span>
        {
<span class="nc" id="L570">            throw new WikiSecurityException(e.getMessage(), e );</span>
<span class="fc" id="L571">        }</span>

        // Initialize the LoginModule
<span class="fc" id="L574">        Subject subject = new Subject();</span>
<span class="fc" id="L575">        loginModule.initialize( subject, handler, EMPTY_MAP, options );</span>

        // Try to log in:
<span class="fc" id="L578">        boolean loginSucceeded = false;</span>
<span class="fc" id="L579">        boolean commitSucceeded = false;</span>
        try
        {
<span class="fc" id="L582">            loginSucceeded = loginModule.login();</span>
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">            if (loginSucceeded)</span>
            {
<span class="fc" id="L585">                commitSucceeded = loginModule.commit();</span>
            }
        }
<span class="fc" id="L588">        catch (LoginException e)</span>
        {
            // Login or commit failed! No principal for you!
<span class="fc" id="L591">        }</span>

        // If we successfully logged in &amp; committed, return all the principals
<span class="pc bpc" id="L594" title="1 of 4 branches missed.">        if (loginSucceeded &amp;&amp; commitSucceeded)</span>
        {
<span class="fc" id="L596">            return subject.getPrincipals();</span>
        }
<span class="fc" id="L598">        return NO_PRINCIPALS;</span>
    }

    /**
     * Looks up and obtains a configuration file inside the WEB-INF folder of a
     * wiki webapp.
     * @param engine the wiki engine
     * @param name the file to obtain, &lt;em&gt;e.g.&lt;/em&gt;, &lt;code&gt;jspwiki.policy&lt;/code&gt;
     * @return the URL to the file
     */
    protected static URL findConfigFile( WikiEngine engine, String name )
    {
<span class="fc" id="L610">        log.info( &quot;looking for &quot; + name + &quot; inside WEB-INF &quot; );</span>
        // Try creating an absolute path first
<span class="fc" id="L612">        File defaultFile = null;</span>
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">        if( engine.getRootPath() != null )</span>
        {
<span class="nc" id="L615">            defaultFile = new File( engine.getRootPath() + &quot;/WEB-INF/&quot; + name );</span>
        }
<span class="pc bpc" id="L617" title="3 of 4 branches missed.">        if ( defaultFile != null &amp;&amp; defaultFile.exists() )</span>
        {
            try
            {
<span class="nc" id="L621">                return defaultFile.toURI().toURL();</span>
            }
<span class="nc" id="L623">            catch ( MalformedURLException e)</span>
            {
                // Shouldn't happen, but log it if it does
<span class="nc" id="L626">                log.warn( &quot;Malformed URL: &quot; + e.getMessage() );</span>
            }

        }

        
        // Ok, the absolute path didn't work; try other methods

<span class="fc" id="L634">        URL path = null;</span>
        
<span class="pc bpc" id="L636" title="1 of 2 branches missed.">        if( engine.getServletContext() != null )</span>
        {
<span class="fc" id="L638">        	OutputStream os = null;</span>
<span class="fc" id="L639">        	InputStream is = null;</span>
            try
            {
<span class="fc" id="L642">            	URL url = engine.getServletContext().getResource(&quot;/WEB-INF/&quot; + name);</span>
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">            	if (url != null)</span>
            	{
<span class="nc" id="L645">            		return url;</span>
            	}
            	
<span class="fc" id="L648">                log.info( &quot;looking for /&quot; + name + &quot; on classpath&quot; );</span>
                //  create a tmp file of the policy loaded as an InputStream and return the URL to it
                //  
<span class="fc" id="L651">                is = AuthenticationManager.class.getResourceAsStream( &quot;/&quot; + name );</span>
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">                if( is == null ) {</span>
<span class="nc" id="L653">                    throw new FileNotFoundException( name + &quot; not found&quot; );</span>
                }
<span class="fc" id="L655">                File tmpFile = File.createTempFile( &quot;temp.&quot; + name, &quot;&quot; );</span>
<span class="fc" id="L656">                tmpFile.deleteOnExit();</span>

<span class="fc" id="L658">                os = new FileOutputStream(tmpFile);</span>

<span class="fc" id="L660">                byte[] buff = new byte[1024];</span>
<span class="fc" id="L661">                int bytes = 0;</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">                while ((bytes = is.read(buff)) != -1) {</span>
<span class="fc" id="L663">                    os.write(buff, 0, bytes);</span>
                }

<span class="fc" id="L666">                path = tmpFile.toURI().toURL();</span>
            }
<span class="nc" id="L668">            catch( MalformedURLException e )</span>
            {
                // This should never happen unless I screw up
<span class="nc" id="L671">                log.fatal( &quot;Your code is b0rked.  You are a bad person.&quot;, e );</span>
            }
<span class="nc" id="L673">            catch (IOException e)</span>
            {
<span class="nc" id="L675">               log.error( &quot;failed to load security policy from file &quot; + name + &quot;,stacktrace follows&quot;, e );</span>
            }
            finally 
            {
<span class="fc" id="L679">            	IOUtils.closeQuietly( is );</span>
<span class="fc" id="L680">            	IOUtils.closeQuietly( os );</span>
            }
        }
<span class="fc" id="L683">        return path;</span>
    }

    /**
     * Returns the first Principal in a set that isn't a {@link org.apache.wiki.auth.authorize.Role} or
     * {@link org.apache.wiki.auth.GroupPrincipal}.
     * @param principals the principal set
     * @return the login principal
     */
    protected Principal getLoginPrincipal(Set&lt;Principal&gt; principals)
    {
<span class="pc bpc" id="L694" title="1 of 2 branches missed.">        for (Principal principal: principals )</span>
        {
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">            if ( isUserPrincipal( principal ) )</span>
            {
<span class="fc" id="L698">                return principal;</span>
            }
<span class="nc" id="L700">        }</span>
<span class="nc" id="L701">        return null;</span>
    }

    // events processing .......................................................

    /**
     * Registers a WikiEventListener with this instance.
     * This is a convenience method.
     * @param listener the event listener
     */
    public synchronized void addWikiEventListener( WikiEventListener listener )
    {
<span class="fc" id="L713">        WikiEventManager.addWikiEventListener( this, listener );</span>
<span class="fc" id="L714">    }</span>

    /**
     * Un-registers a WikiEventListener with this instance.
     * This is a convenience method.
     * @param listener the event listener
     */
    public synchronized void removeWikiEventListener( WikiEventListener listener )
    {
<span class="nc" id="L723">        WikiEventManager.removeWikiEventListener( this, listener );</span>
<span class="nc" id="L724">    }</span>

    /**
     *  Fires a WikiSecurityEvent of the provided type, Principal and target Object
     *  to all registered listeners.
     *
     * @see org.apache.wiki.event.WikiSecurityEvent
     * @param type       the event type to be fired
     * @param principal  the subject of the event, which may be &lt;code&gt;null&lt;/code&gt;
     * @param target     the changed Object, which may be &lt;code&gt;null&lt;/code&gt;
     */
    protected void fireEvent( int type, Principal principal, Object target )
    {
<span class="pc bpc" id="L737" title="1 of 2 branches missed.">        if ( WikiEventManager.isListening(this) )</span>
        {
<span class="fc" id="L739">            WikiEventManager.fireEvent(this,new WikiSecurityEvent(this,type,principal,target));</span>
        }
<span class="fc" id="L741">    }</span>
    
    /**
     * Initializes the options Map supplied to the configured LoginModule every time it is invoked.
     * The properties and values extracted from
     * &lt;code&gt;jspwiki.properties&lt;/code&gt; are of the form
     * &lt;code&gt;jspwiki.loginModule.options.&lt;var&gt;param&lt;/var&gt; = &lt;var&gt;value&lt;/var&gt;, where
     * &lt;var&gt;param&lt;/var&gt; is the key name, and &lt;var&gt;value&lt;/var&gt; is the value.
     * @param props the properties used to initialize JSPWiki
     * @throws IllegalArgumentException if any of the keys are duplicated
     */
    private void initLoginModuleOptions(Properties props)
    {
<span class="fc bfc" id="L754" title="All 2 branches covered.">        for ( Object key : props.keySet() )</span>
        {
<span class="fc" id="L756">            String propName = key.toString();</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">            if ( propName.startsWith( PREFIX_LOGIN_MODULE_OPTIONS ) )</span>
            {
                // Extract the option name and value
<span class="fc" id="L760">                String optionKey = propName.substring( PREFIX_LOGIN_MODULE_OPTIONS.length() ).trim();</span>
<span class="pc bpc" id="L761" title="1 of 2 branches missed.">                if ( optionKey.length() &gt; 0 )</span>
                {
<span class="fc" id="L763">                    String optionValue = props.getProperty( propName );</span>
                    
                    // Make sure the key is unique before stashing the key/value pair
<span class="pc bpc" id="L766" title="1 of 2 branches missed.">                    if ( m_loginModuleOptions.containsKey( optionKey ) )</span>
                    {
<span class="nc" id="L768">                        throw new IllegalArgumentException( &quot;JAAS LoginModule key &quot; + propName + &quot; cannot be specified twice!&quot; );</span>
                    }
<span class="fc" id="L770">                    m_loginModuleOptions.put( optionKey, optionValue );</span>
                }
            }
<span class="fc" id="L773">        }</span>
<span class="fc" id="L774">    }</span>
    
    /**
     * After successful login, this method is called to inject authorized role Principals into the WikiSession.
     * To determine which roles should be injected, the configured Authorizer
     * is queried for the roles it knows about by calling  {@link org.apache.wiki.auth.Authorizer#getRoles()}.
     * Then, each role returned by the authorizer is tested by calling {@link org.apache.wiki.auth.Authorizer#isUserInRole(WikiSession, Principal)}.
     * If this check fails, and the Authorizer is of type WebAuthorizer, the role is checked again by calling
     * {@link org.apache.wiki.auth.authorize.WebAuthorizer#isUserInRole(javax.servlet.http.HttpServletRequest, Principal)}).
     * Any roles that pass the test are injected into the Subject by firing appropriate authentication events.
     * @param session the user's current WikiSession
     * @param authorizer the WikiEngine's configured Authorizer
     * @param request the user's HTTP session, which may be &lt;code&gt;null&lt;/code&gt;
     */
    private void injectAuthorizerRoles( WikiSession session, Authorizer authorizer, HttpServletRequest request )
    {
        // Test each role the authorizer knows about
<span class="fc bfc" id="L791" title="All 2 branches covered.">        for ( Principal role : authorizer.getRoles() )</span>
        {
            // Test the Authorizer
<span class="fc bfc" id="L794" title="All 2 branches covered.">            if ( authorizer.isUserInRole( session, role ) )</span>
            {
<span class="fc" id="L796">                fireEvent( WikiSecurityEvent.PRINCIPAL_ADD, role, session );</span>
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">                if ( log.isDebugEnabled() )</span>
                {
<span class="nc" id="L799">                    log.debug(&quot;Added authorizer role &quot; + role.getName() + &quot;.&quot; );</span>
                }
            }
            
            // If web authorizer, test the request.isInRole() method also
<span class="pc bpc" id="L804" title="1 of 4 branches missed.">            else if ( request != null &amp;&amp; authorizer instanceof WebAuthorizer )</span>
            {
<span class="fc" id="L806">                WebAuthorizer wa = (WebAuthorizer)authorizer;</span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">                if ( wa.isUserInRole( request, role ) )</span>
                {
<span class="fc" id="L809">                    fireEvent( WikiSecurityEvent.PRINCIPAL_ADD, role, session );</span>
<span class="pc bpc" id="L810" title="1 of 2 branches missed.">                    if ( log.isDebugEnabled() )</span>
                    {
<span class="nc" id="L812">                        log.debug(&quot;Added container role &quot; + role.getName() + &quot;.&quot; );</span>
                    }
                }
            }
        }
<span class="fc" id="L817">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>