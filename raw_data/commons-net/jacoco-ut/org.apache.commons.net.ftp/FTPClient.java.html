<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FTPClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Net</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.net.ftp</a> &gt; <span class="el_source">FTPClient.java</span></div><h1>FTPClient.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.net.ftp;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Locale;
import java.util.Properties;
import java.util.Random;
import java.util.Set;

import org.apache.commons.net.MalformedServerReplyException;
import org.apache.commons.net.ftp.parser.DefaultFTPFileEntryParserFactory;
import org.apache.commons.net.ftp.parser.FTPFileEntryParserFactory;
import org.apache.commons.net.ftp.parser.MLSxEntryParser;
import org.apache.commons.net.io.CRLFLineReader;
import org.apache.commons.net.io.CopyStreamAdapter;
import org.apache.commons.net.io.CopyStreamEvent;
import org.apache.commons.net.io.CopyStreamListener;
import org.apache.commons.net.io.FromNetASCIIInputStream;
import org.apache.commons.net.io.ToNetASCIIOutputStream;
import org.apache.commons.net.io.Util;

/**
 * FTPClient encapsulates all the functionality necessary to store and
 * retrieve files from an FTP server.  This class takes care of all
 * low level details of interacting with an FTP server and provides
 * a convenient higher level interface.  As with all classes derived
 * from {@link org.apache.commons.net.SocketClient},
 * you must first connect to the server with
 * {@link org.apache.commons.net.SocketClient#connect  connect }
 * before doing anything, and finally
 * {@link org.apache.commons.net.SocketClient#disconnect  disconnect }
 * after you're completely finished interacting with the server.
 * Then you need to check the FTP reply code to see if the connection
 * was successful.  For example:
 * &lt;pre&gt;
 *    FTPClient ftp = new FTPClient();
 *    FTPClientConfig config = new FTPClientConfig();
 *    config.setXXX(YYY); // change required options
 *    // for example config.setServerTimeZoneId(&quot;Pacific/Pitcairn&quot;)
 *    ftp.configure(config );
 *    boolean error = false;
 *    try {
 *      int reply;
 *      String server = &quot;ftp.example.com&quot;;
 *      ftp.connect(server);
 *      System.out.println(&quot;Connected to &quot; + server + &quot;.&quot;);
 *      System.out.print(ftp.getReplyString());
 *
 *      // After connection attempt, you should check the reply code to verify
 *      // success.
 *      reply = ftp.getReplyCode();
 *
 *      if(!FTPReply.isPositiveCompletion(reply)) {
 *        ftp.disconnect();
 *        System.err.println(&quot;FTP server refused connection.&quot;);
 *        System.exit(1);
 *      }
 *      ... // transfer files
 *      ftp.logout();
 *    } catch(IOException e) {
 *      error = true;
 *      e.printStackTrace();
 *    } finally {
 *      if(ftp.isConnected()) {
 *        try {
 *          ftp.disconnect();
 *        } catch(IOException ioe) {
 *          // do nothing
 *        }
 *      }
 *      System.exit(error ? 1 : 0);
 *    }
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Immediately after connecting is the only real time you need to check the
 * reply code (because connect is of type void).  The convention for all the
 * FTP command methods in FTPClient is such that they either return a
 * boolean value or some other value.
 * The boolean methods return true on a successful completion reply from
 * the FTP server and false on a reply resulting in an error condition or
 * failure.  The methods returning a value other than boolean return a value
 * containing the higher level data produced by the FTP command, or null if a
 * reply resulted in an error condition or failure.  If you want to access
 * the exact FTP reply code causing a success or failure, you must call
 * {@link org.apache.commons.net.ftp.FTP#getReplyCode  getReplyCode } after
 * a success or failure.
 * &lt;p&gt;
 * The default settings for FTPClient are for it to use
 * &lt;code&gt; FTP.ASCII_FILE_TYPE &lt;/code&gt;,
 * &lt;code&gt; FTP.NON_PRINT_TEXT_FORMAT &lt;/code&gt;,
 * &lt;code&gt; FTP.STREAM_TRANSFER_MODE &lt;/code&gt;, and
 * &lt;code&gt; FTP.FILE_STRUCTURE &lt;/code&gt;.  The only file types directly supported
 * are &lt;code&gt; FTP.ASCII_FILE_TYPE &lt;/code&gt; and
 * &lt;code&gt; FTP.BINARY_FILE_TYPE &lt;/code&gt;.  Because there are at least 4
 * different EBCDIC encodings, we have opted not to provide direct support
 * for EBCDIC.  To transfer EBCDIC and other unsupported file types you
 * must create your own filter InputStreams and OutputStreams and wrap
 * them around the streams returned or required by the FTPClient methods.
 * FTPClient uses the {@link ToNetASCIIOutputStream NetASCII}
 * filter streams to provide transparent handling of ASCII files.  We will
 * consider incorporating EBCDIC support if there is enough demand.
 * &lt;p&gt;
 * &lt;code&gt; FTP.NON_PRINT_TEXT_FORMAT &lt;/code&gt;,
 * &lt;code&gt; FTP.STREAM_TRANSFER_MODE &lt;/code&gt;, and
 * &lt;code&gt; FTP.FILE_STRUCTURE &lt;/code&gt; are the only supported formats,
 * transfer modes, and file structures.
 * &lt;p&gt;
 * Because the handling of sockets on different platforms can differ
 * significantly, the FTPClient automatically issues a new PORT (or EPRT) command
 * prior to every transfer requiring that the server connect to the client's
 * data port.  This ensures identical problem-free behavior on Windows, Unix,
 * and Macintosh platforms.  Additionally, it relieves programmers from
 * having to issue the PORT (or EPRT) command themselves and dealing with platform
 * dependent issues.
 * &lt;p&gt;
 * Additionally, for security purposes, all data connections to the
 * client are verified to ensure that they originated from the intended
 * party (host and port).  If a data connection is initiated by an unexpected
 * party, the command will close the socket and throw an IOException.  You
 * may disable this behavior with
 * {@link #setRemoteVerificationEnabled setRemoteVerificationEnabled()}.
 * &lt;p&gt;
 * You should keep in mind that the FTP server may choose to prematurely
 * close a connection if the client has been idle for longer than a
 * given time period (usually 900 seconds).  The FTPClient class will detect a
 * premature FTP server connection closing when it receives a
 * {@link org.apache.commons.net.ftp.FTPReply#SERVICE_NOT_AVAILABLE FTPReply.SERVICE_NOT_AVAILABLE }
 *  response to a command.
 * When that occurs, the FTP class method encountering that reply will throw
 * an {@link org.apache.commons.net.ftp.FTPConnectionClosedException}
 * .
 * &lt;code&gt;FTPConnectionClosedException&lt;/code&gt;
 * is a subclass of &lt;code&gt; IOException &lt;/code&gt; and therefore need not be
 * caught separately, but if you are going to catch it separately, its
 * catch block must appear before the more general &lt;code&gt; IOException &lt;/code&gt;
 * catch block.  When you encounter an
 * {@link org.apache.commons.net.ftp.FTPConnectionClosedException}
 * , you must disconnect the connection with
 * {@link #disconnect  disconnect() } to properly clean up the
 * system resources used by FTPClient.  Before disconnecting, you may check the
 * last reply code and text with
 * {@link org.apache.commons.net.ftp.FTP#getReplyCode  getReplyCode },
 * {@link org.apache.commons.net.ftp.FTP#getReplyString  getReplyString },
 * and
 * {@link org.apache.commons.net.ftp.FTP#getReplyStrings  getReplyStrings}.
 * You may avoid server disconnections while the client is idle by
 * periodically sending NOOP commands to the server.
 * &lt;p&gt;
 * Rather than list it separately for each method, we mention here that
 * every method communicating with the server and throwing an IOException
 * can also throw a
 * {@link org.apache.commons.net.MalformedServerReplyException}
 * , which is a subclass
 * of IOException.  A MalformedServerReplyException will be thrown when
 * the reply received from the server deviates enough from the protocol
 * specification that it cannot be interpreted in a useful manner despite
 * attempts to be as lenient as possible.
 * &lt;p&gt;
 * Listing API Examples
 * Both paged and unpaged examples of directory listings are available,
 * as follows:
 * &lt;p&gt;
 * Unpaged (whole list) access, using a parser accessible by auto-detect:
 * &lt;pre&gt;
 *    FTPClient f = new FTPClient();
 *    f.connect(server);
 *    f.login(username, password);
 *    FTPFile[] files = f.listFiles(directory);
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Paged access, using a parser not accessible by auto-detect.  The class
 * defined in the first parameter of initateListParsing should be derived
 * from org.apache.commons.net.FTPFileEntryParser:
 * &lt;pre&gt;
 *    FTPClient f = new FTPClient();
 *    f.connect(server);
 *    f.login(username, password);
 *    FTPListParseEngine engine =
 *       f.initiateListParsing(&quot;com.whatever.YourOwnParser&quot;, directory);
 *
 *    while (engine.hasNext()) {
 *       FTPFile[] files = engine.getNext(25);  // &quot;page size&quot; you want
 *       //do whatever you want with these files, display them, etc.
 *       //expensive FTPFile objects not created until needed.
 *    }
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Paged access, using a parser accessible by auto-detect:
 * &lt;pre&gt;
 *    FTPClient f = new FTPClient();
 *    f.connect(server);
 *    f.login(username, password);
 *    FTPListParseEngine engine = f.initiateListParsing(directory);
 *
 *    while (engine.hasNext()) {
 *       FTPFile[] files = engine.getNext(25);  // &quot;page size&quot; you want
 *       //do whatever you want with these files, display them, etc.
 *       //expensive FTPFile objects not created until needed.
 *    }
 * &lt;/pre&gt;
 * &lt;p&gt;
 * For examples of using FTPClient on servers whose directory listings
 * &lt;ul&gt;
 * &lt;li&gt;use languages other than English&lt;/li&gt;
 * &lt;li&gt;use date formats other than the American English &quot;standard&quot; &lt;code&gt;MM d yyyy&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;are in different timezones and you need accurate timestamps for dependency checking
 *     as in Ant&lt;/li&gt;
 * &lt;/ul&gt;see {@link  FTPClientConfig  FTPClientConfig}.
 * &lt;p&gt;
 * &lt;b&gt;Control channel keep-alive feature&lt;/b&gt;:
 * &lt;p&gt;
 * &lt;b&gt;Please note:&lt;/b&gt; this does not apply to the methods where the user is responsible for writing or reading
 * the data stream, i.e. {@link #retrieveFileStream(String)} , {@link #storeFileStream(String)}
 * and the other xxxFileStream methods
 * &lt;p&gt;
 * During file transfers, the data connection is busy, but the control connection is idle.
 * FTP servers know that the control connection is in use, so won't close it through lack of activity,
 * but it's a lot harder for network routers to know that the control and data connections are associated
 * with each other.
 * Some routers may treat the control connection as idle, and disconnect it if the transfer over the data
 * connection takes longer than the allowable idle time for the router.
 * &lt;br&gt;
 * One solution to this is to send a safe command (i.e. NOOP) over the control connection to reset the router's
 * idle timer. This is enabled as follows:
 * &lt;pre&gt;
 *     ftpClient.setControlKeepAliveTimeout(300); // set timeout to 5 minutes
 * &lt;/pre&gt;
 * This will cause the file upload/download methods to send a NOOP approximately every 5 minutes.
 * The following public methods support this:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #retrieveFile(String, OutputStream)}&lt;/li&gt;
 * &lt;li&gt;{@link #appendFile(String, InputStream)}&lt;/li&gt;
 * &lt;li&gt;{@link #storeFile(String, InputStream)}&lt;/li&gt;
 * &lt;li&gt;{@link #storeUniqueFile(InputStream)}&lt;/li&gt;
 * &lt;li&gt;{@link #storeUniqueFileStream(String)}&lt;/li&gt;
 * &lt;/ul&gt;
 * This feature does not apply to the methods where the user is responsible for writing or reading
 * the data stream, i.e. {@link #retrieveFileStream(String)} , {@link #storeFileStream(String)}
 * and the other xxxFileStream methods.
 * In such cases, the user is responsible for keeping the control connection alive if necessary.
 * &lt;p&gt;
 * The implementation currently uses a {@link CopyStreamListener} which is passed to the
 * {@link Util#copyStream(InputStream, OutputStream, int, long, CopyStreamListener, boolean)}
 * method, so the timing is partially dependent on how long each block transfer takes.
 *
 * @see #FTP_SYSTEM_TYPE
 * @see #SYSTEM_TYPE_PROPERTIES
 * @see FTP
 * @see FTPConnectionClosedException
 * @see FTPFileEntryParser
 * @see FTPFileEntryParserFactory
 * @see DefaultFTPFileEntryParserFactory
 * @see FTPClientConfig
 *
 * @see org.apache.commons.net.MalformedServerReplyException
 */
public class FTPClient extends FTP
implements Configurable
{
    /**
     * The system property ({@value}) which can be used to override the system type.&lt;br&gt;
     * If defined, the value will be used to create any automatically created parsers.
     *
     * @since 3.0
     */
    public static final String FTP_SYSTEM_TYPE = &quot;org.apache.commons.net.ftp.systemType&quot;;

    /**
     * The system property ({@value}) which can be used as the default system type.&lt;br&gt;
     * If defined, the value will be used if the SYST command fails.
     *
     * @since 3.1
     */
    public static final String FTP_SYSTEM_TYPE_DEFAULT = &quot;org.apache.commons.net.ftp.systemType.default&quot;;

    /**
     * The name of an optional systemType properties file ({@value}), which is loaded
     * using {@link Class#getResourceAsStream(String)}.&lt;br&gt;
     * The entries are the systemType (as determined by {@link FTPClient#getSystemType})
     * and the values are the replacement type or parserClass, which is passed to
     * {@link FTPFileEntryParserFactory#createFileEntryParser(String)}.&lt;br&gt;
     * For example:
     * &lt;pre&gt;
     * Plan 9=Unix
     * OS410=org.apache.commons.net.ftp.parser.OS400FTPEntryParser
     * &lt;/pre&gt;
     *
     * @since 3.0
     */
    public static final String SYSTEM_TYPE_PROPERTIES = &quot;/systemType.properties&quot;;

    /**
     * A constant indicating the FTP session is expecting all transfers
     * to occur between the client (local) and server and that the server
     * should connect to the client's data port to initiate a data transfer.
     * This is the default data connection mode when and FTPClient instance
     * is created.
     */
    public static final int ACTIVE_LOCAL_DATA_CONNECTION_MODE = 0;
    /**
     * A constant indicating the FTP session is expecting all transfers
     * to occur between two remote servers and that the server
     * the client is connected to should connect to the other server's
     * data port to initiate a data transfer.
     */
    public static final int ACTIVE_REMOTE_DATA_CONNECTION_MODE = 1;
    /**
     * A constant indicating the FTP session is expecting all transfers
     * to occur between the client (local) and server and that the server
     * is in passive mode, requiring the client to connect to the
     * server's data port to initiate a transfer.
     */
    public static final int PASSIVE_LOCAL_DATA_CONNECTION_MODE = 2;
    /**
     * A constant indicating the FTP session is expecting all transfers
     * to occur between two remote servers and that the server
     * the client is connected to is in passive mode, requiring the other
     * server to connect to the first server's data port to initiate a data
     * transfer.
     */
    public static final int PASSIVE_REMOTE_DATA_CONNECTION_MODE = 3;

    private int __dataConnectionMode;
    private int __dataTimeout;
    private int __passivePort;
    private String __passiveHost;
    private final Random __random;
    private int __activeMinPort;
    private int __activeMaxPort;
    private InetAddress __activeExternalHost;
    private InetAddress __reportActiveExternalHost; // overrides __activeExternalHost in EPRT/PORT commands
    /** The address to bind to on passive connections, if necessary. */
    private InetAddress __passiveLocalHost;

    private int __fileType;
    @SuppressWarnings(&quot;unused&quot;) // fields are written, but currently not read
    private int __fileFormat;
    @SuppressWarnings(&quot;unused&quot;) // field is written, but currently not read
    private int __fileStructure;
    @SuppressWarnings(&quot;unused&quot;) // field is written, but currently not read
    private int __fileTransferMode;
    private boolean __remoteVerificationEnabled;
    private long __restartOffset;
    private FTPFileEntryParserFactory __parserFactory;
    private int __bufferSize; // buffersize for buffered data streams
    private int __sendDataSocketBufferSize;
    private int __receiveDataSocketBufferSize;
    private boolean __listHiddenFiles;
    private boolean __useEPSVwithIPv4; // whether to attempt EPSV with an IPv4 connection

    // __systemName is a cached value that should not be referenced directly
    // except when assigned in getSystemName and __initDefaults.
    private String __systemName;

    // __entryParser is a cached value that should not be referenced directly
    // except when assigned in listFiles(String, String) and __initDefaults.
    private FTPFileEntryParser __entryParser;

    // Key used to create the parser; necessary to ensure that the parser type is not ignored
    private String __entryParserKey;

    private FTPClientConfig __configuration;

    // Listener used by store/retrieve methods to handle keepalive
    private CopyStreamListener __copyStreamListener;

    // How long to wait before sending another control keep-alive message
    private long __controlKeepAliveTimeout;

    // How long to wait (ms) for keepalive message replies before continuing
    // Most FTP servers don't seem to support concurrent control and data connection usage
<span class="fc" id="L406">    private int __controlKeepAliveReplyTimeout=1000;</span>

    /**
     * Enable or disable replacement of internal IP in passive mode. Default enabled
     * using {code NatServerResolverImpl}.
     */
<span class="fc" id="L412">    private HostnameResolver __passiveNatWorkaroundStrategy = new NatServerResolverImpl(this);</span>

    /** Pattern for PASV mode responses. Groups: (n,n,n,n),(n),(n) */
    private static final java.util.regex.Pattern __PARMS_PAT;

    static {
<span class="fc" id="L418">        __PARMS_PAT = java.util.regex.Pattern.compile(</span>
                &quot;(\\d{1,3},\\d{1,3},\\d{1,3},\\d{1,3}),(\\d{1,3}),(\\d{1,3})&quot;);
<span class="fc" id="L420">    }</span>

    /** Controls the automatic server encoding detection (only UTF-8 supported). */
<span class="fc" id="L423">    private boolean __autodetectEncoding = false;</span>

    /** Map of FEAT responses. If null, has not been initialised. */
    private HashMap&lt;String, Set&lt;String&gt;&gt; __featuresMap;

    private static class PropertiesSingleton {

        static final Properties PROPERTIES;

        static {
<span class="fc" id="L433">            InputStream resourceAsStream = FTPClient.class.getResourceAsStream(SYSTEM_TYPE_PROPERTIES);</span>
<span class="fc" id="L434">            Properties p = null;</span>
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">            if (resourceAsStream != null) {</span>
<span class="nc" id="L436">                p = new Properties();</span>
                try {
<span class="nc" id="L438">                    p.load(resourceAsStream);</span>
<span class="nc" id="L439">                } catch (IOException e) {</span>
                    // Ignored
                } finally {
                    try {
<span class="nc" id="L443">                        resourceAsStream.close();</span>
<span class="nc" id="L444">                    } catch (IOException e) {</span>
                        // Ignored
<span class="nc" id="L446">                    }</span>
                }
            }
<span class="fc" id="L449">            PROPERTIES = p;</span>
<span class="fc" id="L450">        }</span>

    }
    private static Properties getOverrideProperties(){
<span class="fc" id="L454">        return PropertiesSingleton.PROPERTIES;</span>
    }

    /**
     * Default FTPClient constructor.  Creates a new FTPClient instance
     * with the data connection mode set to
     * &lt;code&gt; ACTIVE_LOCAL_DATA_CONNECTION_MODE &lt;/code&gt;, the file type
     * set to &lt;code&gt; FTP.ASCII_FILE_TYPE &lt;/code&gt;, the
     * file format set to &lt;code&gt; FTP.NON_PRINT_TEXT_FORMAT &lt;/code&gt;,
     * the file structure set to &lt;code&gt; FTP.FILE_STRUCTURE &lt;/code&gt;, and
     * the transfer mode set to &lt;code&gt; FTP.STREAM_TRANSFER_MODE &lt;/code&gt;.
     * &lt;p&gt;
     * The list parsing auto-detect feature can be configured to use lenient future
     * dates (short dates may be up to one day in the future) as follows:
     * &lt;pre&gt;
     * FTPClient ftp = new FTPClient();
     * FTPClientConfig config = new FTPClientConfig();
     * config.setLenientFutureDates(true);
     * ftp.configure(config );
     * &lt;/pre&gt;
     */
    public FTPClient()
<span class="fc" id="L476">    {</span>
<span class="fc" id="L477">        __initDefaults();</span>
<span class="fc" id="L478">        __dataTimeout = -1;</span>
<span class="fc" id="L479">        __remoteVerificationEnabled = true;</span>
<span class="fc" id="L480">        __parserFactory = new DefaultFTPFileEntryParserFactory();</span>
<span class="fc" id="L481">        __configuration      = null;</span>
<span class="fc" id="L482">        __listHiddenFiles = false;</span>
<span class="fc" id="L483">        __useEPSVwithIPv4 = false;</span>
<span class="fc" id="L484">        __random = new Random();</span>
<span class="fc" id="L485">        __passiveLocalHost   = null;</span>
<span class="fc" id="L486">    }</span>


    private void __initDefaults()
    {
<span class="fc" id="L491">        __dataConnectionMode = ACTIVE_LOCAL_DATA_CONNECTION_MODE;</span>
<span class="fc" id="L492">        __passiveHost        = null;</span>
<span class="fc" id="L493">        __passivePort        = -1;</span>
<span class="fc" id="L494">        __activeExternalHost = null;</span>
<span class="fc" id="L495">        __reportActiveExternalHost = null;</span>
<span class="fc" id="L496">        __activeMinPort = 0;</span>
<span class="fc" id="L497">        __activeMaxPort = 0;</span>
<span class="fc" id="L498">        __fileType           = FTP.ASCII_FILE_TYPE;</span>
<span class="fc" id="L499">        __fileStructure      = FTP.FILE_STRUCTURE;</span>
<span class="fc" id="L500">        __fileFormat         = FTP.NON_PRINT_TEXT_FORMAT;</span>
<span class="fc" id="L501">        __fileTransferMode   = FTP.STREAM_TRANSFER_MODE;</span>
<span class="fc" id="L502">        __restartOffset      = 0;</span>
<span class="fc" id="L503">        __systemName         = null;</span>
<span class="fc" id="L504">        __entryParser        = null;</span>
<span class="fc" id="L505">        __entryParserKey    = &quot;&quot;;</span>
<span class="fc" id="L506">        __featuresMap = null;</span>
<span class="fc" id="L507">    }</span>

    /**
     * Parse the pathname from a CWD reply.
     * &lt;p&gt;
     * According to RFC959 (http://www.ietf.org/rfc/rfc959.txt),
     * it should be the same as for MKD i.e.
     * {@code 257&lt;space&gt;&quot;&lt;directory-name&gt;&quot;[&lt;space&gt;commentary]}
     * where any double-quotes in {@code &lt;directory-name&gt;} are doubled.
     * Unlike MKD, the commentary is optional.
     * &lt;p&gt;
     * However, see NET-442 for an exception.
     *
     * @param reply
     * @return the pathname, without enclosing quotes,
     * or the full string after the reply code and space if the syntax is invalid
     * (i.e. enclosing quotes are missing or embedded quotes are not doubled)
     */
    // package protected for access by test cases
    static String __parsePathname(String reply)
    {
<span class="fc" id="L528">        String param = reply.substring(REPLY_CODE_LEN + 1);</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">        if (param.startsWith(&quot;\&quot;&quot;)) {</span>
<span class="fc" id="L530">            StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L531">            boolean quoteSeen = false;</span>
            // start after initial quote
<span class="fc bfc" id="L533" title="All 2 branches covered.">            for(int i=1; i &lt; param.length(); i++) {</span>
<span class="fc" id="L534">                char ch = param.charAt(i);</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">                if (ch=='&quot;') {</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">                    if (quoteSeen) {</span>
<span class="fc" id="L537">                        sb.append(ch);</span>
<span class="fc" id="L538">                        quoteSeen=false;</span>
                    } else {
                        // don't output yet, in case doubled
<span class="fc" id="L541">                        quoteSeen=true;</span>
                    }
                } else {
<span class="fc bfc" id="L544" title="All 2 branches covered.">                    if (quoteSeen) { // found lone trailing quote within string</span>
<span class="fc" id="L545">                        return sb.toString();</span>
                    }
<span class="fc" id="L547">                    sb.append(ch); // just another character</span>
                }
            }
<span class="fc bfc" id="L550" title="All 2 branches covered.">            if (quoteSeen) { // found lone trailing quote at end of string</span>
<span class="fc" id="L551">                return sb.toString();</span>
            }
        }
        // malformed reply, return all after reply code and space
<span class="fc" id="L555">        return param;</span>
    }

    /**
     * @since 3.1
     * @param reply the reply to parse
     * @throws MalformedServerReplyException if the server reply does not match  (n,n,n,n),(n),(n)
     */
    protected void _parsePassiveModeReply(String reply)
    throws MalformedServerReplyException
    {
<span class="fc" id="L566">        java.util.regex.Matcher m = __PARMS_PAT.matcher(reply);</span>
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">        if (!m.find()) {</span>
<span class="nc" id="L568">            throw new MalformedServerReplyException(</span>
                    &quot;Could not parse passive host information.\nServer Reply: &quot; + reply);
        }

<span class="fc" id="L572">        __passiveHost = m.group(1).replace(',', '.'); // Fix up to look like IP address</span>

        try
        {
<span class="fc" id="L576">            int oct1 = Integer.parseInt(m.group(2));</span>
<span class="fc" id="L577">            int oct2 = Integer.parseInt(m.group(3));</span>
<span class="fc" id="L578">            __passivePort = (oct1 &lt;&lt; 8) | oct2;</span>
        }
<span class="nc" id="L580">        catch (NumberFormatException e)</span>
        {
<span class="nc" id="L582">            throw new MalformedServerReplyException(</span>
                    &quot;Could not parse passive port information.\nServer Reply: &quot; + reply);
<span class="fc" id="L584">        }</span>

<span class="fc bfc" id="L586" title="All 2 branches covered.">        if (__passiveNatWorkaroundStrategy != null) {</span>
            try {
<span class="fc" id="L588">                String passiveHost = __passiveNatWorkaroundStrategy.resolve(__passiveHost);</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">                if (!__passiveHost.equals(passiveHost)) {</span>
<span class="fc" id="L590">                    fireReplyReceived(0,</span>
                            &quot;[Replacing PASV mode reply address &quot;+__passiveHost+&quot; with &quot;+passiveHost+&quot;]\n&quot;);
<span class="fc" id="L592">                    __passiveHost = passiveHost;</span>
                }
<span class="nc" id="L594">            } catch (UnknownHostException e) { // Should not happen as we are passing in an IP address</span>
<span class="nc" id="L595">                throw new MalformedServerReplyException(</span>
                        &quot;Could not parse passive host information.\nServer Reply: &quot; + reply);
<span class="fc" id="L597">            }</span>
        }
<span class="fc" id="L599">    }</span>

    protected void _parseExtendedPassiveModeReply(String reply)
    throws MalformedServerReplyException
    {
<span class="nc" id="L604">        reply = reply.substring(reply.indexOf('(') + 1,</span>
<span class="nc" id="L605">                reply.indexOf(')')).trim();</span>

        char delim1, delim2, delim3, delim4;
<span class="nc" id="L608">        delim1 = reply.charAt(0);</span>
<span class="nc" id="L609">        delim2 = reply.charAt(1);</span>
<span class="nc" id="L610">        delim3 = reply.charAt(2);</span>
<span class="nc" id="L611">        delim4 = reply.charAt(reply.length()-1);</span>

<span class="nc bnc" id="L613" title="All 6 branches missed.">        if (!(delim1 == delim2) || !(delim2 == delim3)</span>
                || !(delim3 == delim4)) {
<span class="nc" id="L615">            throw new MalformedServerReplyException(</span>
                    &quot;Could not parse extended passive host information.\nServer Reply: &quot; + reply);
        }

        int port;
        try
        {
<span class="nc" id="L622">            port = Integer.parseInt(reply.substring(3, reply.length()-1));</span>
        }
<span class="nc" id="L624">        catch (NumberFormatException e)</span>
        {
<span class="nc" id="L626">            throw new MalformedServerReplyException(</span>
                    &quot;Could not parse extended passive host information.\nServer Reply: &quot; + reply);
<span class="nc" id="L628">        }</span>


        // in EPSV mode, the passive host address is implicit
<span class="nc" id="L632">        __passiveHost = getRemoteAddress().getHostAddress();</span>
<span class="nc" id="L633">        __passivePort = port;</span>
<span class="nc" id="L634">    }</span>

    private boolean __storeFile(FTPCmd command, String remote, InputStream local)
    throws IOException
    {
<span class="nc" id="L639">        return _storeFile(command.getCommand(), remote, local);</span>
    }

    /**
     * @since 3.1
     * @param command the command to send
     * @param remote the remote file name
     * @param local the local file name
     * @return true if successful
     * @throws IOException on error
     */
    protected boolean _storeFile(String command, String remote, InputStream local)
    throws IOException
    {
<span class="nc" id="L653">        Socket socket = _openDataConnection_(command, remote);</span>

<span class="nc bnc" id="L655" title="All 2 branches missed.">        if (socket == null) {</span>
<span class="nc" id="L656">            return false;</span>
        }

        final OutputStream output;

<span class="nc bnc" id="L661" title="All 2 branches missed.">        if (__fileType == ASCII_FILE_TYPE) {</span>
<span class="nc" id="L662">            output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));</span>
        } else {
<span class="nc" id="L664">            output = getBufferedOutputStream(socket.getOutputStream());</span>
        }

<span class="nc" id="L667">        CSL csl = null;</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">        if (__controlKeepAliveTimeout &gt; 0) {</span>
<span class="nc" id="L669">            csl = new CSL(this, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);</span>
        }

        // Treat everything else as binary for now
        try
        {
<span class="nc" id="L675">            Util.copyStream(local, output, getBufferSize(),</span>
<span class="nc" id="L676">                    CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl),</span>
                    false);
        }
<span class="nc" id="L679">        catch (IOException e)</span>
        {
<span class="nc" id="L681">            Util.closeQuietly(socket); // ignore close errors here</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">            if (csl != null) {</span>
<span class="nc" id="L683">                csl.cleanUp(); // fetch any outstanding keepalive replies</span>
            }
<span class="nc" id="L685">            throw e;</span>
<span class="nc" id="L686">        }</span>

<span class="nc" id="L688">        output.close(); // ensure the file is fully written</span>
<span class="nc" id="L689">        socket.close(); // done writing the file</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">        if (csl != null) {</span>
<span class="nc" id="L691">            csl.cleanUp(); // fetch any outstanding keepalive replies</span>
        }
        // Get the transfer response
<span class="nc" id="L694">        boolean ok = completePendingCommand();</span>
<span class="nc" id="L695">        return ok;</span>
    }

    private OutputStream __storeFileStream(FTPCmd command, String remote)
    throws IOException
    {
<span class="nc" id="L701">        return _storeFileStream(command.getCommand(), remote);</span>
    }

    /**
     * @param command the command to send
     * @param remote the remote file name
     * @return the output stream to write to
     * @throws IOException on error
     * @since 3.1
     */
    protected OutputStream _storeFileStream(String command, String remote)
    throws IOException
    {
<span class="nc" id="L714">        Socket socket = _openDataConnection_(command, remote);</span>

<span class="nc bnc" id="L716" title="All 2 branches missed.">        if (socket == null) {</span>
<span class="nc" id="L717">            return null;</span>
        }

        final OutputStream output;
<span class="nc bnc" id="L721" title="All 2 branches missed.">        if (__fileType == ASCII_FILE_TYPE) {</span>
            // We buffer ascii transfers because the buffering has to
            // be interposed between ToNetASCIIOutputSream and the underlying
            // socket output stream.  We don't buffer binary transfers
            // because we don't want to impose a buffering policy on the
            // programmer if possible.  Programmers can decide on their
            // own if they want to wrap the SocketOutputStream we return
            // for file types other than ASCII.
<span class="nc" id="L729">            output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));</span>
        } else {
<span class="nc" id="L731">            output = socket.getOutputStream();</span>
        }
<span class="nc" id="L733">        return new org.apache.commons.net.io.SocketOutputStream(socket, output);</span>
    }


    /**
     * Establishes a data connection with the FTP server, returning
     * a Socket for the connection if successful.  If a restart
     * offset has been set with {@link #setRestartOffset(long)},
     * a REST command is issued to the server with the offset as
     * an argument before establishing the data connection.  Active
     * mode connections also cause a local PORT command to be issued.
     *
     * @param command  The int representation of the FTP command to send.
     * @param arg The arguments to the FTP command.  If this parameter is
     *             set to null, then the command is sent with no argument.
     * @return A Socket corresponding to the established data connection.
     *         Null is returned if an FTP protocol error is reported at
     *         any point during the establishment and initialization of
     *         the connection.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     * @deprecated (3.3) Use {@link #_openDataConnection_(FTPCmd, String)} instead
     */
    @Deprecated
    protected Socket _openDataConnection_(int command, String arg)
    throws IOException
    {
<span class="nc" id="L760">        return _openDataConnection_(FTPCommand.getCommand(command), arg);</span>
    }

    /**
     * Establishes a data connection with the FTP server, returning
     * a Socket for the connection if successful.  If a restart
     * offset has been set with {@link #setRestartOffset(long)},
     * a REST command is issued to the server with the offset as
     * an argument before establishing the data connection.  Active
     * mode connections also cause a local PORT command to be issued.
     *
     * @param command  The int representation of the FTP command to send.
     * @param arg The arguments to the FTP command.  If this parameter is
     *             set to null, then the command is sent with no argument.
     * @return A Socket corresponding to the established data connection.
     *         Null is returned if an FTP protocol error is reported at
     *         any point during the establishment and initialization of
     *         the connection.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     * @since 3.3
     */
    protected Socket _openDataConnection_(FTPCmd command, String arg)
    throws IOException
    {
<span class="nc" id="L785">        return _openDataConnection_(command.getCommand(), arg);</span>
    }

    /**
     * Establishes a data connection with the FTP server, returning
     * a Socket for the connection if successful.  If a restart
     * offset has been set with {@link #setRestartOffset(long)},
     * a REST command is issued to the server with the offset as
     * an argument before establishing the data connection.  Active
     * mode connections also cause a local PORT command to be issued.
     *
     * @param command  The text representation of the FTP command to send.
     * @param arg The arguments to the FTP command.  If this parameter is
     *             set to null, then the command is sent with no argument.
     * @return A Socket corresponding to the established data connection.
     *         Null is returned if an FTP protocol error is reported at
     *         any point during the establishment and initialization of
     *         the connection.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     * @since 3.1
     */
    protected Socket _openDataConnection_(String command, String arg)
    throws IOException
    {
<span class="nc bnc" id="L810" title="All 4 branches missed.">        if (__dataConnectionMode != ACTIVE_LOCAL_DATA_CONNECTION_MODE &amp;&amp;</span>
                __dataConnectionMode != PASSIVE_LOCAL_DATA_CONNECTION_MODE) {
<span class="nc" id="L812">            return null;</span>
        }

<span class="nc" id="L815">        final boolean isInet6Address = getRemoteAddress() instanceof Inet6Address;</span>

        Socket socket;

<span class="nc bnc" id="L819" title="All 2 branches missed.">        if (__dataConnectionMode == ACTIVE_LOCAL_DATA_CONNECTION_MODE)</span>
        {
            // if no activePortRange was set (correctly) -&gt; getActivePort() = 0
            // -&gt; new ServerSocket(0) -&gt; bind to any free local port
<span class="nc" id="L823">            ServerSocket server = _serverSocketFactory_.createServerSocket(getActivePort(), 1, getHostAddress());</span>

            try {
                // Try EPRT only if remote server is over IPv6, if not use PORT,
                // because EPRT has no advantage over PORT on IPv4.
                // It could even have the disadvantage,
                // that EPRT will make the data connection fail, because
                // today's intelligent NAT Firewalls are able to
                // substitute IP addresses in the PORT command,
                // but might not be able to recognize the EPRT command.
<span class="nc bnc" id="L833" title="All 2 branches missed.">                if (isInet6Address) {</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">                    if (!FTPReply.isPositiveCompletion(eprt(getReportHostAddress(), server.getLocalPort()))) {</span>
<span class="nc" id="L835">                        return null;</span>
                    }
                } else {
<span class="nc bnc" id="L838" title="All 2 branches missed.">                    if (!FTPReply.isPositiveCompletion(port(getReportHostAddress(), server.getLocalPort()))) {</span>
<span class="nc" id="L839">                        return null;</span>
                    }
                }

<span class="nc bnc" id="L843" title="All 4 branches missed.">                if ((__restartOffset &gt; 0) &amp;&amp; !restart(__restartOffset)) {</span>
<span class="nc" id="L844">                    return null;</span>
                }

<span class="nc bnc" id="L847" title="All 2 branches missed.">                if (!FTPReply.isPositivePreliminary(sendCommand(command, arg))) {</span>
<span class="nc" id="L848">                    return null;</span>
                }

                // For now, let's just use the data timeout value for waiting for
                // the data connection.  It may be desirable to let this be a
                // separately configurable value.  In any case, we really want
                // to allow preventing the accept from blocking indefinitely.
<span class="nc bnc" id="L855" title="All 2 branches missed.">                if (__dataTimeout &gt;= 0) {</span>
<span class="nc" id="L856">                    server.setSoTimeout(__dataTimeout);</span>
                }
<span class="nc" id="L858">                socket = server.accept();</span>

                // Ensure the timeout is set before any commands are issued on the new socket
<span class="nc bnc" id="L861" title="All 2 branches missed.">                if (__dataTimeout &gt;= 0) {</span>
<span class="nc" id="L862">                    socket.setSoTimeout(__dataTimeout);</span>
                }
<span class="nc bnc" id="L864" title="All 2 branches missed.">                if (__receiveDataSocketBufferSize &gt; 0) {</span>
<span class="nc" id="L865">                    socket.setReceiveBufferSize(__receiveDataSocketBufferSize);</span>
                }
<span class="nc bnc" id="L867" title="All 2 branches missed.">                if (__sendDataSocketBufferSize &gt; 0) {</span>
<span class="nc" id="L868">                    socket.setSendBufferSize(__sendDataSocketBufferSize);</span>
                }
            } finally {
<span class="nc" id="L871">                server.close();</span>
            }
<span class="nc" id="L873">        }</span>
        else
        { // We must be in PASSIVE_LOCAL_DATA_CONNECTION_MODE

            // Try EPSV command first on IPv6 - and IPv4 if enabled.
            // When using IPv4 with NAT it has the advantage
            // to work with more rare configurations.
            // E.g. if FTP server has a static PASV address (external network)
            // and the client is coming from another internal network.
            // In that case the data connection after PASV command would fail,
            // while EPSV would make the client succeed by taking just the port.
<span class="nc bnc" id="L884" title="All 4 branches missed.">            boolean attemptEPSV = isUseEPSVwithIPv4() || isInet6Address;</span>
<span class="nc bnc" id="L885" title="All 4 branches missed.">            if (attemptEPSV &amp;&amp; epsv() == FTPReply.ENTERING_EPSV_MODE)</span>
            {
<span class="nc" id="L887">                _parseExtendedPassiveModeReply(_replyLines.get(0));</span>
            }
            else
            {
<span class="nc bnc" id="L891" title="All 2 branches missed.">                if (isInet6Address) {</span>
<span class="nc" id="L892">                    return null; // Must use EPSV for IPV6</span>
                }
                // If EPSV failed on IPV4, revert to PASV
<span class="nc bnc" id="L895" title="All 2 branches missed.">                if (pasv() != FTPReply.ENTERING_PASSIVE_MODE) {</span>
<span class="nc" id="L896">                    return null;</span>
                }
<span class="nc" id="L898">                _parsePassiveModeReply(_replyLines.get(0));</span>
            }

<span class="nc" id="L901">            socket = _socketFactory_.createSocket();</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">            if (__receiveDataSocketBufferSize &gt; 0) {</span>
<span class="nc" id="L903">                socket.setReceiveBufferSize(__receiveDataSocketBufferSize);</span>
            }
<span class="nc bnc" id="L905" title="All 2 branches missed.">            if (__sendDataSocketBufferSize &gt; 0) {</span>
<span class="nc" id="L906">                socket.setSendBufferSize(__sendDataSocketBufferSize);</span>
            }
<span class="nc bnc" id="L908" title="All 2 branches missed.">            if (__passiveLocalHost != null) {</span>
<span class="nc" id="L909">                socket.bind(new InetSocketAddress(__passiveLocalHost, 0));</span>
            }

            // For now, let's just use the data timeout value for waiting for
            // the data connection.  It may be desirable to let this be a
            // separately configurable value.  In any case, we really want
            // to allow preventing the accept from blocking indefinitely.
<span class="nc bnc" id="L916" title="All 2 branches missed.">            if (__dataTimeout &gt;= 0) {</span>
<span class="nc" id="L917">                socket.setSoTimeout(__dataTimeout);</span>
            }

<span class="nc" id="L920">            socket.connect(new InetSocketAddress(__passiveHost, __passivePort), connectTimeout);</span>
<span class="nc bnc" id="L921" title="All 4 branches missed.">            if ((__restartOffset &gt; 0) &amp;&amp; !restart(__restartOffset))</span>
            {
<span class="nc" id="L923">                socket.close();</span>
<span class="nc" id="L924">                return null;</span>
            }

<span class="nc bnc" id="L927" title="All 2 branches missed.">            if (!FTPReply.isPositivePreliminary(sendCommand(command, arg)))</span>
            {
<span class="nc" id="L929">                socket.close();</span>
<span class="nc" id="L930">                return null;</span>
            }
        }

<span class="nc bnc" id="L934" title="All 4 branches missed.">        if (__remoteVerificationEnabled &amp;&amp; !verifyRemote(socket))</span>
        {
<span class="nc" id="L936">            socket.close();</span>

<span class="nc" id="L938">            throw new IOException(</span>
<span class="nc" id="L939">                    &quot;Host attempting data connection &quot; + socket.getInetAddress().getHostAddress() +</span>
<span class="nc" id="L940">                    &quot; is not same as server &quot; + getRemoteAddress().getHostAddress());</span>
        }

<span class="nc" id="L943">        return socket;</span>
    }


    @Override
    protected void _connectAction_() throws IOException
    {
<span class="nc" id="L950">        _connectAction_(null);</span>
<span class="nc" id="L951">    }</span>


    /**
     * @param socketIsReader the reader to reuse (if non-null)
     * @throws IOException on error
     * @since 3.4
     */
    @Override
    protected void _connectAction_(Reader socketIsReader) throws IOException
    {
<span class="nc" id="L962">        super._connectAction_(socketIsReader); // sets up _input_ and _output_</span>
<span class="nc" id="L963">        __initDefaults();</span>
        // must be after super._connectAction_(), because otherwise we get an
        // Exception claiming we're not connected
<span class="nc bnc" id="L966" title="All 2 branches missed.">        if ( __autodetectEncoding )</span>
        {
<span class="nc" id="L968">            ArrayList&lt;String&gt; oldReplyLines = new ArrayList&lt;String&gt; (_replyLines);</span>
<span class="nc" id="L969">            int oldReplyCode = _replyCode;</span>
<span class="nc bnc" id="L970" title="All 4 branches missed.">            if ( hasFeature(&quot;UTF8&quot;) || hasFeature(&quot;UTF-8&quot;)) // UTF8 appears to be the default</span>
            {
<span class="nc" id="L972">                 setControlEncoding(&quot;UTF-8&quot;);</span>
<span class="nc" id="L973">                 _controlInput_ =</span>
<span class="nc" id="L974">                     new CRLFLineReader(new InputStreamReader(_input_, getControlEncoding()));</span>
<span class="nc" id="L975">                 _controlOutput_ =</span>
<span class="nc" id="L976">                    new BufferedWriter(new OutputStreamWriter(_output_, getControlEncoding()));</span>
            }
            // restore the original reply (server greeting)
<span class="nc" id="L979">            _replyLines.clear();</span>
<span class="nc" id="L980">            _replyLines.addAll(oldReplyLines);</span>
<span class="nc" id="L981">            _replyCode = oldReplyCode;</span>
<span class="nc" id="L982">            _newReplyString = true;</span>
        }
<span class="nc" id="L984">    }</span>


    /**
     * Sets the timeout in milliseconds to use when reading from the
     * data connection.  This timeout will be set immediately after
     * opening the data connection, provided that the value is &amp;ge; 0.
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt; the timeout will also be applied when calling accept()
     * whilst establishing an active local data connection.
     * @param  timeout The default timeout in milliseconds that is used when
     *        opening a data connection socket. The value 0 means an infinite timeout.
     */
    public void setDataTimeout(int timeout)
    {
<span class="nc" id="L999">        __dataTimeout = timeout;</span>
<span class="nc" id="L1000">    }</span>

    /**
     * set the factory used for parser creation to the supplied factory object.
     *
     * @param parserFactory
     *               factory object used to create FTPFileEntryParsers
     *
     * @see org.apache.commons.net.ftp.parser.FTPFileEntryParserFactory
     * @see org.apache.commons.net.ftp.parser.DefaultFTPFileEntryParserFactory
     */
    public void setParserFactory(FTPFileEntryParserFactory parserFactory) {
<span class="nc" id="L1012">        __parserFactory = parserFactory;</span>
<span class="nc" id="L1013">    }</span>


    /**
     * Closes the connection to the FTP server and restores
     * connection parameters to the default values.
     *
     * @throws IOException If an error occurs while disconnecting.
     */
    @Override
    public void disconnect() throws IOException
    {
<span class="nc" id="L1025">        super.disconnect();</span>
<span class="nc" id="L1026">        __initDefaults();</span>
<span class="nc" id="L1027">    }</span>


    /**
     * Enable or disable verification that the remote host taking part
     * of a data connection is the same as the host to which the control
     * connection is attached.  The default is for verification to be
     * enabled.  You may set this value at any time, whether the
     * FTPClient is currently connected or not.
     *
     * @param enable True to enable verification, false to disable verification.
     */
    public void setRemoteVerificationEnabled(boolean enable)
    {
<span class="nc" id="L1041">        __remoteVerificationEnabled = enable;</span>
<span class="nc" id="L1042">    }</span>

    /**
     * Return whether or not verification of the remote host participating
     * in data connections is enabled.  The default behavior is for
     * verification to be enabled.
     *
     * @return True if verification is enabled, false if not.
     */
    public boolean isRemoteVerificationEnabled()
    {
<span class="nc" id="L1053">        return __remoteVerificationEnabled;</span>
    }

    /**
     * Login to the FTP server using the provided username and password.
     *
     * @param username The username to login under.
     * @param password The password to use.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean login(String username, String password) throws IOException
    {

<span class="nc" id="L1073">        user(username);</span>

<span class="nc bnc" id="L1075" title="All 2 branches missed.">        if (FTPReply.isPositiveCompletion(_replyCode)) {</span>
<span class="nc" id="L1076">            return true;</span>
        }

        // If we get here, we either have an error code, or an intermmediate
        // reply requesting password.
<span class="nc bnc" id="L1081" title="All 2 branches missed.">        if (!FTPReply.isPositiveIntermediate(_replyCode)) {</span>
<span class="nc" id="L1082">            return false;</span>
        }

<span class="nc" id="L1085">        return FTPReply.isPositiveCompletion(pass(password));</span>
    }


    /**
     * Login to the FTP server using the provided username, password,
     * and account.  If no account is required by the server, only
     * the username and password, the account information is not used.
     *
     * @param username The username to login under.
     * @param password The password to use.
     * @param account  The account to use.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean login(String username, String password, String account)
    throws IOException
    {
<span class="nc" id="L1109">        user(username);</span>

<span class="nc bnc" id="L1111" title="All 2 branches missed.">        if (FTPReply.isPositiveCompletion(_replyCode)) {</span>
<span class="nc" id="L1112">            return true;</span>
        }

        // If we get here, we either have an error code, or an intermmediate
        // reply requesting password.
<span class="nc bnc" id="L1117" title="All 2 branches missed.">        if (!FTPReply.isPositiveIntermediate(_replyCode)) {</span>
<span class="nc" id="L1118">            return false;</span>
        }

<span class="nc" id="L1121">        pass(password);</span>

<span class="nc bnc" id="L1123" title="All 2 branches missed.">        if (FTPReply.isPositiveCompletion(_replyCode)) {</span>
<span class="nc" id="L1124">            return true;</span>
        }

<span class="nc bnc" id="L1127" title="All 2 branches missed.">        if (!FTPReply.isPositiveIntermediate(_replyCode)) {</span>
<span class="nc" id="L1128">            return false;</span>
        }

<span class="nc" id="L1131">        return FTPReply.isPositiveCompletion(acct(account));</span>
    }

    /**
     * Logout of the FTP server by sending the QUIT command.
     *
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean logout() throws IOException
    {
<span class="nc" id="L1148">        return FTPReply.isPositiveCompletion(quit());</span>
    }


    /**
     * Change the current working directory of the FTP session.
     *
     * @param pathname  The new current working directory.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean changeWorkingDirectory(String pathname) throws IOException
    {
<span class="nc" id="L1167">        return FTPReply.isPositiveCompletion(cwd(pathname));</span>
    }


    /**
     * Change to the parent directory of the current working directory.
     *
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean changeToParentDirectory() throws IOException
    {
<span class="nc" id="L1185">        return FTPReply.isPositiveCompletion(cdup());</span>
    }


    /**
     * Issue the FTP SMNT command.
     *
     * @param pathname The pathname to mount.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean structureMount(String pathname) throws IOException
    {
<span class="nc" id="L1204">        return FTPReply.isPositiveCompletion(smnt(pathname));</span>
    }

    /**
     * Reinitialize the FTP session.  Not all FTP servers support this
     * command, which issues the FTP REIN command.
     *
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     * @since 3.4 (made public)
     */
    public boolean reinitialize() throws IOException
    {
<span class="nc" id="L1223">        rein();</span>

<span class="nc bnc" id="L1225" title="All 2 branches missed.">        if (FTPReply.isPositiveCompletion(_replyCode) ||</span>
<span class="nc bnc" id="L1226" title="All 2 branches missed.">                (FTPReply.isPositivePreliminary(_replyCode) &amp;&amp;</span>
<span class="nc bnc" id="L1227" title="All 2 branches missed.">                        FTPReply.isPositiveCompletion(getReply())))</span>
        {

<span class="nc" id="L1230">            __initDefaults();</span>

<span class="nc" id="L1232">            return true;</span>
        }

<span class="nc" id="L1235">        return false;</span>
    }


    /**
     * Set the current data connection mode to
     * &lt;code&gt;ACTIVE_LOCAL_DATA_CONNECTION_MODE&lt;/code&gt;.  No communication
     * with the FTP server is conducted, but this causes all future data
     * transfers to require the FTP server to connect to the client's
     * data port.  Additionally, to accommodate differences between socket
     * implementations on different platforms, this method causes the
     * client to issue a PORT command before every data transfer.
     */
    public void enterLocalActiveMode()
    {
<span class="nc" id="L1250">        __dataConnectionMode = ACTIVE_LOCAL_DATA_CONNECTION_MODE;</span>
<span class="nc" id="L1251">        __passiveHost = null;</span>
<span class="nc" id="L1252">        __passivePort = -1;</span>
<span class="nc" id="L1253">    }</span>


    /**
     * Set the current data connection mode to
     * &lt;code&gt; PASSIVE_LOCAL_DATA_CONNECTION_MODE &lt;/code&gt;.  Use this
     * method only for data transfers between the client and server.
     * This method causes a PASV (or EPSV) command to be issued to the server
     * before the opening of every data connection, telling the server to
     * open a data port to which the client will connect to conduct
     * data transfers.  The FTPClient will stay in
     * &lt;code&gt; PASSIVE_LOCAL_DATA_CONNECTION_MODE &lt;/code&gt; until the
     * mode is changed by calling some other method such as
     * {@link #enterLocalActiveMode  enterLocalActiveMode() }
     * &lt;p&gt;
     * &lt;b&gt;N.B.&lt;/b&gt; currently calling any connect method will reset the mode to
     * ACTIVE_LOCAL_DATA_CONNECTION_MODE.
     */
    public void enterLocalPassiveMode()
    {
<span class="nc" id="L1273">        __dataConnectionMode = PASSIVE_LOCAL_DATA_CONNECTION_MODE;</span>
        // These will be set when just before a data connection is opened
        // in _openDataConnection_()
<span class="nc" id="L1276">        __passiveHost = null;</span>
<span class="nc" id="L1277">        __passivePort = -1;</span>
<span class="nc" id="L1278">    }</span>


    /**
     * Set the current data connection mode to
     * &lt;code&gt; ACTIVE_REMOTE_DATA_CONNECTION &lt;/code&gt;.  Use this method only
     * for server to server data transfers.  This method issues a PORT
     * command to the server, indicating the other server and port to which
     * it should connect for data transfers.  You must call this method
     * before EVERY server to server transfer attempt.  The FTPClient will
     * NOT automatically continue to issue PORT commands.  You also
     * must remember to call
     * {@link #enterLocalActiveMode  enterLocalActiveMode() } if you
     * wish to return to the normal data connection mode.
     *
     * @param host The passive mode server accepting connections for data
     *             transfers.
     * @param port The passive mode server's data port.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean enterRemoteActiveMode(InetAddress host, int port)
    throws IOException
    {
<span class="nc bnc" id="L1308" title="All 2 branches missed.">        if (FTPReply.isPositiveCompletion(port(host, port)))</span>
        {
<span class="nc" id="L1310">            __dataConnectionMode = ACTIVE_REMOTE_DATA_CONNECTION_MODE;</span>
<span class="nc" id="L1311">            __passiveHost = null;</span>
<span class="nc" id="L1312">            __passivePort = -1;</span>
<span class="nc" id="L1313">            return true;</span>
        }
<span class="nc" id="L1315">        return false;</span>
    }

    /**
     * Set the current data connection mode to
     * &lt;code&gt; PASSIVE_REMOTE_DATA_CONNECTION_MODE &lt;/code&gt;.  Use this
     * method only for server to server data transfers.
     * This method issues a PASV command to the server, telling it to
     * open a data port to which the active server will connect to conduct
     * data transfers.  You must call this method
     * before EVERY server to server transfer attempt.  The FTPClient will
     * NOT automatically continue to issue PASV commands.  You also
     * must remember to call
     * {@link #enterLocalActiveMode  enterLocalActiveMode() } if you
     * wish to return to the normal data connection mode.
     *
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean enterRemotePassiveMode() throws IOException
    {
<span class="nc bnc" id="L1342" title="All 2 branches missed.">        if (pasv() != FTPReply.ENTERING_PASSIVE_MODE) {</span>
<span class="nc" id="L1343">            return false;</span>
        }

<span class="nc" id="L1346">        __dataConnectionMode = PASSIVE_REMOTE_DATA_CONNECTION_MODE;</span>
<span class="nc" id="L1347">        _parsePassiveModeReply(_replyLines.get(0));</span>

<span class="nc" id="L1349">        return true;</span>
    }

    /**
     * Returns the hostname or IP address (in the form of a string) returned
     * by the server when entering passive mode.  If not in passive mode,
     * returns null.  This method only returns a valid value AFTER a
     * data connection has been opened after a call to
     * {@link #enterLocalPassiveMode enterLocalPassiveMode()}.
     * This is because FTPClient sends a PASV command to the server only
     * just before opening a data connection, and not when you call
     * {@link #enterLocalPassiveMode enterLocalPassiveMode()}.
     *
     * @return The passive host name if in passive mode, otherwise null.
     */
    public String getPassiveHost()
    {
<span class="fc" id="L1366">        return __passiveHost;</span>
    }

    /**
     * If in passive mode, returns the data port of the passive host.
     * This method only returns a valid value AFTER a
     * data connection has been opened after a call to
     * {@link #enterLocalPassiveMode enterLocalPassiveMode()}.
     * This is because FTPClient sends a PASV command to the server only
     * just before opening a data connection, and not when you call
     * {@link #enterLocalPassiveMode enterLocalPassiveMode()}.
     *
     * @return The data port of the passive server.  If not in passive
     *         mode, undefined.
     */
    public int getPassivePort()
    {
<span class="nc" id="L1383">        return __passivePort;</span>
    }


    /**
     * Returns the current data connection mode (one of the
     * &lt;code&gt; _DATA_CONNECTION_MODE &lt;/code&gt; constants.
     *
     * @return The current data connection mode (one of the
     * &lt;code&gt; _DATA_CONNECTION_MODE &lt;/code&gt; constants.
     */
    public int getDataConnectionMode()
    {
<span class="nc" id="L1396">        return __dataConnectionMode;</span>
    }

    /**
     * Get the client port for active mode.
     *
     * @return The client port for active mode.
     */
    private int getActivePort()
    {
<span class="nc bnc" id="L1406" title="All 4 branches missed.">        if (__activeMinPort &gt; 0 &amp;&amp; __activeMaxPort &gt;= __activeMinPort)</span>
        {
<span class="nc bnc" id="L1408" title="All 2 branches missed.">            if (__activeMaxPort == __activeMinPort) {</span>
<span class="nc" id="L1409">                return __activeMaxPort;</span>
            }
            // Get a random port between the min and max port range
<span class="nc" id="L1412">            return __random.nextInt(__activeMaxPort - __activeMinPort + 1) + __activeMinPort;</span>
        }
        else
        {
            // default port
<span class="nc" id="L1417">            return 0;</span>
        }
    }

    /**
     * Get the host address for active mode; allows the local address to be overridden.
     *
     * @return __activeExternalHost if non-null, else getLocalAddress()
     * @see #setActiveExternalIPAddress(String)
     */
    private InetAddress getHostAddress()
    {
<span class="nc bnc" id="L1429" title="All 2 branches missed.">        if (__activeExternalHost != null)</span>
        {
<span class="nc" id="L1431">            return __activeExternalHost;</span>
        }
        else
        {
            // default local address
<span class="nc" id="L1436">            return getLocalAddress();</span>
        }
    }

    /**
     * Get the reported host address for active mode EPRT/PORT commands;
     * allows override of {@link #getHostAddress()}.
     *
     * Useful for FTP Client behind Firewall NAT.
     *
     * @return __reportActiveExternalHost if non-null, else getHostAddress();
     */
    private InetAddress getReportHostAddress() {
<span class="nc bnc" id="L1449" title="All 2 branches missed.">        if (__reportActiveExternalHost != null) {</span>
<span class="nc" id="L1450">            return __reportActiveExternalHost ;</span>
        } else {
<span class="nc" id="L1452">            return getHostAddress();</span>
        }
    }

    /**
     * Set the client side port range in active mode.
     *
     * @param minPort The lowest available port (inclusive).
     * @param maxPort The highest available port (inclusive).
     * @since 2.2
     */
    public void setActivePortRange(int minPort, int maxPort)
    {
<span class="nc" id="L1465">        this.__activeMinPort = minPort;</span>
<span class="nc" id="L1466">        this.__activeMaxPort = maxPort;</span>
<span class="nc" id="L1467">    }</span>

    /**
     * Set the external IP address in active mode.
     * Useful when there are multiple network cards.
     *
     * @param ipAddress The external IP address of this machine.
     * @throws UnknownHostException if the ipAddress cannot be resolved
     * @since 2.2
     */
    public void setActiveExternalIPAddress(String ipAddress) throws UnknownHostException
    {
<span class="nc" id="L1479">        this.__activeExternalHost = InetAddress.getByName(ipAddress);</span>
<span class="nc" id="L1480">    }</span>

    /**
     * Set the local IP address to use in passive mode.
     * Useful when there are multiple network cards.
     *
     * @param ipAddress The local IP address of this machine.
     * @throws UnknownHostException if the ipAddress cannot be resolved
     */
    public void setPassiveLocalIPAddress(String ipAddress) throws UnknownHostException
    {
<span class="nc" id="L1491">        this.__passiveLocalHost = InetAddress.getByName(ipAddress);</span>
<span class="nc" id="L1492">    }</span>

    /**
     * Set the local IP address to use in passive mode.
     * Useful when there are multiple network cards.
     *
     * @param inetAddress The local IP address of this machine.
     */
    public void setPassiveLocalIPAddress(InetAddress inetAddress)
    {
<span class="nc" id="L1502">        this.__passiveLocalHost = inetAddress;</span>
<span class="nc" id="L1503">    }</span>

    /**
     * Set the local IP address in passive mode.
     * Useful when there are multiple network cards.
     *
     * @return The local IP address in passive mode.
     */
    public InetAddress getPassiveLocalIPAddress()
    {
<span class="nc" id="L1513">        return this.__passiveLocalHost;</span>
    }

    /**
     * Set the external IP address to report in EPRT/PORT commands in active mode.
     * Useful when there are multiple network cards.
     *
     * @param ipAddress The external IP address of this machine.
     * @throws UnknownHostException if the ipAddress cannot be resolved
     * @since 3.1
     * @see #getReportHostAddress()
     */
    public void setReportActiveExternalIPAddress(String ipAddress) throws UnknownHostException
    {
<span class="nc" id="L1527">        this.__reportActiveExternalHost = InetAddress.getByName(ipAddress);</span>
<span class="nc" id="L1528">    }</span>


    /**
     * Sets the file type to be transferred.  This should be one of
     * &lt;code&gt; FTP.ASCII_FILE_TYPE &lt;/code&gt;, &lt;code&gt; FTP.BINARY_FILE_TYPE&lt;/code&gt;,
     * etc.  The file type only needs to be set when you want to change the
     * type.  After changing it, the new type stays in effect until you change
     * it again.  The default file type is &lt;code&gt; FTP.ASCII_FILE_TYPE &lt;/code&gt;
     * if this method is never called.
     * &lt;br&gt;
     * The server default is supposed to be ASCII (see RFC 959), however many
     * ftp servers default to BINARY. &lt;b&gt;To ensure correct operation with all servers,
     * always specify the appropriate file type after connecting to the server.&lt;/b&gt;
     * &lt;br&gt;
     * &lt;p&gt;
     * &lt;b&gt;N.B.&lt;/b&gt; currently calling any connect method will reset the type to
     * FTP.ASCII_FILE_TYPE.
     * @param fileType The &lt;code&gt; _FILE_TYPE &lt;/code&gt; constant indcating the
     *                 type of file.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean setFileType(int fileType) throws IOException
    {
<span class="nc bnc" id="L1559" title="All 2 branches missed.">        if (FTPReply.isPositiveCompletion(type(fileType)))</span>
        {
<span class="nc" id="L1561">            __fileType = fileType;</span>
<span class="nc" id="L1562">            __fileFormat = FTP.NON_PRINT_TEXT_FORMAT;</span>
<span class="nc" id="L1563">            return true;</span>
        }
<span class="nc" id="L1565">        return false;</span>
    }


    /**
     * Sets the file type to be transferred and the format.  The type should be
     * one of  &lt;code&gt; FTP.ASCII_FILE_TYPE &lt;/code&gt;,
     * &lt;code&gt; FTP.BINARY_FILE_TYPE &lt;/code&gt;, etc.  The file type only needs to
     * be set when you want to change the type.  After changing it, the new
     * type stays in effect until you change it again.  The default file type
     * is &lt;code&gt; FTP.ASCII_FILE_TYPE &lt;/code&gt; if this method is never called.
     * &lt;br&gt;
     * The server default is supposed to be ASCII (see RFC 959), however many
     * ftp servers default to BINARY. &lt;b&gt;To ensure correct operation with all servers,
     * always specify the appropriate file type after connecting to the server.&lt;/b&gt;
     * &lt;br&gt;
     * The format should be one of the FTP class &lt;code&gt; TEXT_FORMAT &lt;/code&gt;
     * constants, or if the type is &lt;code&gt; FTP.LOCAL_FILE_TYPE &lt;/code&gt;, the
     * format should be the byte size for that type.  The default format
     * is &lt;code&gt; FTP.NON_PRINT_TEXT_FORMAT &lt;/code&gt; if this method is never
     * called.
     * &lt;p&gt;
     * &lt;b&gt;N.B.&lt;/b&gt; currently calling any connect method will reset the type to
     * FTP.ASCII_FILE_TYPE and the formatOrByteSize to FTP.NON_PRINT_TEXT_FORMAT.
     *
     * @param fileType The &lt;code&gt; _FILE_TYPE &lt;/code&gt; constant indcating the
     *                 type of file.
     * @param formatOrByteSize  The format of the file (one of the
     *              &lt;code&gt;_FORMAT&lt;/code&gt; constants.  In the case of
     *              &lt;code&gt;LOCAL_FILE_TYPE&lt;/code&gt;, the byte size.
     *
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean setFileType(int fileType, int formatOrByteSize)
    throws IOException
    {
<span class="nc bnc" id="L1608" title="All 2 branches missed.">        if (FTPReply.isPositiveCompletion(type(fileType, formatOrByteSize)))</span>
        {
<span class="nc" id="L1610">            __fileType = fileType;</span>
<span class="nc" id="L1611">            __fileFormat = formatOrByteSize;</span>
<span class="nc" id="L1612">            return true;</span>
        }
<span class="nc" id="L1614">        return false;</span>
    }


    /**
     * Sets the file structure.  The default structure is
     * &lt;code&gt; FTP.FILE_STRUCTURE &lt;/code&gt; if this method is never called
     * or if a connect method is called.
     *
     * @param structure  The structure of the file (one of the FTP class
     *         &lt;code&gt;_STRUCTURE&lt;/code&gt; constants).
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean setFileStructure(int structure) throws IOException
    {
<span class="nc bnc" id="L1636" title="All 2 branches missed.">        if (FTPReply.isPositiveCompletion(stru(structure)))</span>
        {
<span class="nc" id="L1638">            __fileStructure = structure;</span>
<span class="nc" id="L1639">            return true;</span>
        }
<span class="nc" id="L1641">        return false;</span>
    }


    /**
     * Sets the transfer mode.  The default transfer mode
     * &lt;code&gt; FTP.STREAM_TRANSFER_MODE &lt;/code&gt; if this method is never called
     * or if a connect method is called.
     *
     * @param mode  The new transfer mode to use (one of the FTP class
     *         &lt;code&gt;_TRANSFER_MODE&lt;/code&gt; constants).
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean setFileTransferMode(int mode) throws IOException
    {
<span class="nc bnc" id="L1663" title="All 2 branches missed.">        if (FTPReply.isPositiveCompletion(mode(mode)))</span>
        {
<span class="nc" id="L1665">            __fileTransferMode = mode;</span>
<span class="nc" id="L1666">            return true;</span>
        }
<span class="nc" id="L1668">        return false;</span>
    }


    /**
     * Initiate a server to server file transfer.  This method tells the
     * server to which the client is connected to retrieve a given file from
     * the other server.
     *
     * @param filename  The name of the file to retrieve.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean remoteRetrieve(String filename) throws IOException
    {
<span class="nc bnc" id="L1689" title="All 4 branches missed.">        if (__dataConnectionMode == ACTIVE_REMOTE_DATA_CONNECTION_MODE ||</span>
                __dataConnectionMode == PASSIVE_REMOTE_DATA_CONNECTION_MODE) {
<span class="nc" id="L1691">            return FTPReply.isPositivePreliminary(retr(filename));</span>
        }
<span class="nc" id="L1693">        return false;</span>
    }


    /**
     * Initiate a server to server file transfer.  This method tells the
     * server to which the client is connected to store a file on
     * the other server using the given filename.  The other server must
     * have had a &lt;code&gt; remoteRetrieve &lt;/code&gt; issued to it by another
     * FTPClient.
     *
     * @param filename  The name to call the file that is to be stored.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean remoteStore(String filename) throws IOException
    {
<span class="nc bnc" id="L1716" title="All 4 branches missed.">        if (__dataConnectionMode == ACTIVE_REMOTE_DATA_CONNECTION_MODE ||</span>
                __dataConnectionMode == PASSIVE_REMOTE_DATA_CONNECTION_MODE) {
<span class="nc" id="L1718">            return FTPReply.isPositivePreliminary(stor(filename));</span>
        }
<span class="nc" id="L1720">        return false;</span>
    }


    /**
     * Initiate a server to server file transfer.  This method tells the
     * server to which the client is connected to store a file on
     * the other server using a unique filename based on the given filename.
     * The other server must have had a &lt;code&gt; remoteRetrieve &lt;/code&gt; issued
     * to it by another FTPClient.
     *
     * @param filename  The name on which to base the filename of the file
     *                  that is to be stored.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean remoteStoreUnique(String filename) throws IOException
    {
<span class="nc bnc" id="L1744" title="All 4 branches missed.">        if (__dataConnectionMode == ACTIVE_REMOTE_DATA_CONNECTION_MODE ||</span>
                __dataConnectionMode == PASSIVE_REMOTE_DATA_CONNECTION_MODE) {
<span class="nc" id="L1746">            return FTPReply.isPositivePreliminary(stou(filename));</span>
        }
<span class="nc" id="L1748">        return false;</span>
    }


    /**
     * Initiate a server to server file transfer.  This method tells the
     * server to which the client is connected to store a file on
     * the other server using a unique filename.
     * The other server must have had a &lt;code&gt; remoteRetrieve &lt;/code&gt; issued
     * to it by another FTPClient.  Many FTP servers require that a base
     * filename be given from which the unique filename can be derived.  For
     * those servers use the other version of &lt;code&gt; remoteStoreUnique&lt;/code&gt;
     *
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean remoteStoreUnique() throws IOException
    {
<span class="nc bnc" id="L1772" title="All 4 branches missed.">        if (__dataConnectionMode == ACTIVE_REMOTE_DATA_CONNECTION_MODE ||</span>
                __dataConnectionMode == PASSIVE_REMOTE_DATA_CONNECTION_MODE) {
<span class="nc" id="L1774">            return FTPReply.isPositivePreliminary(stou());</span>
        }
<span class="nc" id="L1776">        return false;</span>
    }

    // For server to server transfers
    /**
     * Initiate a server to server file transfer.  This method tells the
     * server to which the client is connected to append to a given file on
     * the other server.  The other server must have had a
     * &lt;code&gt; remoteRetrieve &lt;/code&gt; issued to it by another FTPClient.
     *
     * @param filename  The name of the file to be appended to, or if the
     *        file does not exist, the name to call the file being stored.
     *
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean remoteAppend(String filename) throws IOException
    {
<span class="nc bnc" id="L1800" title="All 4 branches missed.">        if (__dataConnectionMode == ACTIVE_REMOTE_DATA_CONNECTION_MODE ||</span>
                __dataConnectionMode == PASSIVE_REMOTE_DATA_CONNECTION_MODE) {
<span class="nc" id="L1802">            return FTPReply.isPositivePreliminary(appe(filename));</span>
        }
<span class="nc" id="L1804">        return false;</span>
    }

    /**
     * There are a few FTPClient methods that do not complete the
     * entire sequence of FTP commands to complete a transaction.  These
     * commands require some action by the programmer after the reception
     * of a positive intermediate command.  After the programmer's code
     * completes its actions, it must call this method to receive
     * the completion reply from the server and verify the success of the
     * entire transaction.
     * &lt;p&gt;
     * For example,
     * &lt;pre&gt;
     * InputStream input;
     * OutputStream output;
     * input  = new FileInputStream(&quot;foobaz.txt&quot;);
     * output = ftp.storeFileStream(&quot;foobar.txt&quot;)
     * if(!FTPReply.isPositiveIntermediate(ftp.getReplyCode())) {
     *     input.close();
     *     output.close();
     *     ftp.logout();
     *     ftp.disconnect();
     *     System.err.println(&quot;File transfer failed.&quot;);
     *     System.exit(1);
     * }
     * Util.copyStream(input, output);
     * input.close();
     * output.close();
     * // Must call completePendingCommand() to finish command.
     * if(!ftp.completePendingCommand()) {
     *     ftp.logout();
     *     ftp.disconnect();
     *     System.err.println(&quot;File transfer failed.&quot;);
     *     System.exit(1);
     * }
     * &lt;/pre&gt;
     *
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean completePendingCommand() throws IOException
    {
<span class="nc" id="L1853">        return FTPReply.isPositiveCompletion(getReply());</span>
    }


    /**
     * Retrieves a named file from the server and writes it to the given
     * OutputStream.  This method does NOT close the given OutputStream.
     * If the current file type is ASCII, line separators in the file are
     * converted to the local representation.
     * &lt;p&gt;
     * Note: if you have used {@link #setRestartOffset(long)},
     * the file data will start from the selected offset.
     * @param remote  The name of the remote file.
     * @param local   The local OutputStream to which to write the file.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws org.apache.commons.net.io.CopyStreamException
     *      If an I/O error occurs while actually
     *      transferring the file.  The CopyStreamException allows you to
     *      determine the number of bytes transferred and the IOException
     *      causing the error.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean retrieveFile(String remote, OutputStream local)
    throws IOException
    {
<span class="nc" id="L1885">        return _retrieveFile(FTPCmd.RETR.getCommand(), remote, local);</span>
    }

    /**
     * @param command the command to get
     * @param remote the remote file name
     * @param local the local file name
     * @return true if successful
     * @throws IOException on error
     * @since 3.1
     */
    protected boolean _retrieveFile(String command, String remote, OutputStream local)
    throws IOException
    {
<span class="nc" id="L1899">        Socket socket = _openDataConnection_(command, remote);</span>

<span class="nc bnc" id="L1901" title="All 2 branches missed.">        if (socket == null) {</span>
<span class="nc" id="L1902">            return false;</span>
        }

        final InputStream input;
<span class="nc bnc" id="L1906" title="All 2 branches missed.">        if (__fileType == ASCII_FILE_TYPE) {</span>
<span class="nc" id="L1907">            input = new FromNetASCIIInputStream(getBufferedInputStream(socket.getInputStream()));</span>
        } else {
<span class="nc" id="L1909">            input = getBufferedInputStream(socket.getInputStream());</span>
        }

<span class="nc" id="L1912">        CSL csl = null;</span>
<span class="nc bnc" id="L1913" title="All 2 branches missed.">        if (__controlKeepAliveTimeout &gt; 0) {</span>
<span class="nc" id="L1914">            csl = new CSL(this, __controlKeepAliveTimeout, __controlKeepAliveReplyTimeout);</span>
        }

        // Treat everything else as binary for now
        try
        {
<span class="nc" id="L1920">            Util.copyStream(input, local, getBufferSize(),</span>
<span class="nc" id="L1921">                    CopyStreamEvent.UNKNOWN_STREAM_SIZE, __mergeListeners(csl),</span>
                    false);
        } finally {
<span class="nc" id="L1924">            Util.closeQuietly(input);</span>
<span class="nc" id="L1925">            Util.closeQuietly(socket);</span>
<span class="nc bnc" id="L1926" title="All 2 branches missed.">            if (csl != null) {</span>
<span class="nc" id="L1927">                csl.cleanUp(); // fetch any outstanding keepalive replies</span>
            }
        }

        // Get the transfer response
<span class="nc" id="L1932">        boolean ok = completePendingCommand();</span>
<span class="nc" id="L1933">        return ok;</span>
    }

    /**
     * Returns an InputStream from which a named file from the server
     * can be read.  If the current file type is ASCII, the returned
     * InputStream will convert line separators in the file to
     * the local representation.  You must close the InputStream when you
     * finish reading from it.  The InputStream itself will take care of
     * closing the parent data connection socket upon being closed.
     * &lt;p&gt;
     * &lt;b&gt;To finalize the file transfer you must call
     * {@link #completePendingCommand  completePendingCommand } and
     * check its return value to verify success.&lt;/b&gt;
     * If this is not done, subsequent commands may behave unexpectedly.
     * &lt;p&gt;
     * Note: if you have used {@link #setRestartOffset(long)},
     * the file data will start from the selected offset.
     *
     * @param remote  The name of the remote file.
     * @return An InputStream from which the remote file can be read.  If
     *      the data connection cannot be opened (e.g., the file does not
     *      exist), null is returned (in which case you may check the reply
     *      code to determine the exact reason for failure).
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public InputStream retrieveFileStream(String remote) throws IOException
    {
<span class="nc" id="L1967">        return _retrieveFileStream(FTPCmd.RETR.getCommand(), remote);</span>
    }

    /**
     * @param command the command to send
     * @param remote the remote file name
     * @return the stream from which to read the file
     * @throws IOException on error
     * @since 3.1
     */
    protected InputStream _retrieveFileStream(String command, String remote)
    throws IOException
    {
<span class="nc" id="L1980">        Socket socket = _openDataConnection_(command, remote);</span>

<span class="nc bnc" id="L1982" title="All 2 branches missed.">        if (socket == null) {</span>
<span class="nc" id="L1983">            return null;</span>
        }

        final InputStream input;
<span class="nc bnc" id="L1987" title="All 2 branches missed.">        if (__fileType == ASCII_FILE_TYPE) {</span>
            // We buffer ascii transfers because the buffering has to
            // be interposed between FromNetASCIIOutputSream and the underlying
            // socket input stream.  We don't buffer binary transfers
            // because we don't want to impose a buffering policy on the
            // programmer if possible.  Programmers can decide on their
            // own if they want to wrap the SocketInputStream we return
            // for file types other than ASCII.
<span class="nc" id="L1995">            input = new FromNetASCIIInputStream(getBufferedInputStream(socket.getInputStream()));</span>
        } else {
<span class="nc" id="L1997">            input = socket.getInputStream();</span>
        }
<span class="nc" id="L1999">        return new org.apache.commons.net.io.SocketInputStream(socket, input);</span>
    }


    /**
     * Stores a file on the server using the given name and taking input
     * from the given InputStream.  This method does NOT close the given
     * InputStream.  If the current file type is ASCII, line separators in
     * the file are transparently converted to the NETASCII format (i.e.,
     * you should not attempt to create a special InputStream to do this).
     *
     * @param remote  The name to give the remote file.
     * @param local   The local InputStream from which to read the file.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws org.apache.commons.net.io.CopyStreamException
     *      If an I/O error occurs while actually
     *      transferring the file.  The CopyStreamException allows you to
     *      determine the number of bytes transferred and the IOException
     *      causing the error.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean storeFile(String remote, InputStream local)
    throws IOException
    {
<span class="nc" id="L2030">        return __storeFile(FTPCmd.STOR, remote, local);</span>
    }


    /**
     * Returns an OutputStream through which data can be written to store
     * a file on the server using the given name.  If the current file type
     * is ASCII, the returned OutputStream will convert line separators in
     * the file to the NETASCII format  (i.e., you should not attempt to
     * create a special OutputStream to do this).  You must close the
     * OutputStream when you finish writing to it.  The OutputStream itself
     * will take care of closing the parent data connection socket upon being
     * closed.
     * &lt;p&gt;
     * &lt;b&gt;To finalize the file transfer you must call
     * {@link #completePendingCommand  completePendingCommand } and
     * check its return value to verify success.&lt;/b&gt;
     * If this is not done, subsequent commands may behave unexpectedly.
     *
     * @param remote  The name to give the remote file.
     * @return An OutputStream through which the remote file can be written.  If
     *      the data connection cannot be opened (e.g., the file does not
     *      exist), null is returned (in which case you may check the reply
     *      code to determine the exact reason for failure).
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public OutputStream storeFileStream(String remote) throws IOException
    {
<span class="nc" id="L2064">        return __storeFileStream(FTPCmd.STOR, remote);</span>
    }

    /**
     * Appends to a file on the server with the given name, taking input
     * from the given InputStream.  This method does NOT close the given
     * InputStream.  If the current file type is ASCII, line separators in
     * the file are transparently converted to the NETASCII format (i.e.,
     * you should not attempt to create a special InputStream to do this).
     *
     * @param remote  The name of the remote file.
     * @param local   The local InputStream from which to read the data to
     *                be appended to the remote file.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws org.apache.commons.net.io.CopyStreamException
     *      If an I/O error occurs while actually
     *      transferring the file.  The CopyStreamException allows you to
     *      determine the number of bytes transferred and the IOException
     *      causing the error.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean appendFile(String remote, InputStream local)
    throws IOException
    {
<span class="nc" id="L2095">        return __storeFile(FTPCmd.APPE, remote, local);</span>
    }

    /**
     * Returns an OutputStream through which data can be written to append
     * to a file on the server with the given name.  If the current file type
     * is ASCII, the returned OutputStream will convert line separators in
     * the file to the NETASCII format  (i.e., you should not attempt to
     * create a special OutputStream to do this).  You must close the
     * OutputStream when you finish writing to it.  The OutputStream itself
     * will take care of closing the parent data connection socket upon being
     * closed.
     * &lt;p&gt;
     * &lt;b&gt;To finalize the file transfer you must call
     * {@link #completePendingCommand  completePendingCommand } and
     * check its return value to verify success.&lt;/b&gt;
     * If this is not done, subsequent commands may behave unexpectedly.
     *
     * @param remote  The name of the remote file.
     * @return An OutputStream through which the remote file can be appended.
     *      If the data connection cannot be opened (e.g., the file does not
     *      exist), null is returned (in which case you may check the reply
     *      code to determine the exact reason for failure).
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public OutputStream appendFileStream(String remote) throws IOException
    {
<span class="nc" id="L2128">        return __storeFileStream(FTPCmd.APPE, remote);</span>
    }

    /**
     * Stores a file on the server using a unique name derived from the
     * given name and taking input
     * from the given InputStream.  This method does NOT close the given
     * InputStream.  If the current file type is ASCII, line separators in
     * the file are transparently converted to the NETASCII format (i.e.,
     * you should not attempt to create a special InputStream to do this).
     *
     * @param remote  The name on which to base the unique name given to
     *                the remote file.
     * @param local   The local InputStream from which to read the file.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws org.apache.commons.net.io.CopyStreamException
     *      If an I/O error occurs while actually
     *      transferring the file.  The CopyStreamException allows you to
     *      determine the number of bytes transferred and the IOException
     *      causing the error.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean storeUniqueFile(String remote, InputStream local)
    throws IOException
    {
<span class="nc" id="L2160">        return __storeFile(FTPCmd.STOU, remote, local);</span>
    }


    /**
     * Returns an OutputStream through which data can be written to store
     * a file on the server using a unique name derived from the given name.
     * If the current file type
     * is ASCII, the returned OutputStream will convert line separators in
     * the file to the NETASCII format  (i.e., you should not attempt to
     * create a special OutputStream to do this).  You must close the
     * OutputStream when you finish writing to it.  The OutputStream itself
     * will take care of closing the parent data connection socket upon being
     * closed.
     * &lt;p&gt;
     * &lt;b&gt;To finalize the file transfer you must call
     * {@link #completePendingCommand  completePendingCommand } and
     * check its return value to verify success.&lt;/b&gt;
     * If this is not done, subsequent commands may behave unexpectedly.
     *
     * @param remote  The name on which to base the unique name given to
     *                the remote file.
     * @return An OutputStream through which the remote file can be written.  If
     *      the data connection cannot be opened (e.g., the file does not
     *      exist), null is returned (in which case you may check the reply
     *      code to determine the exact reason for failure).
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public OutputStream storeUniqueFileStream(String remote) throws IOException
    {
<span class="nc" id="L2196">        return __storeFileStream(FTPCmd.STOU, remote);</span>
    }

    /**
     * Stores a file on the server using a unique name assigned by the
     * server and taking input from the given InputStream.  This method does
     * NOT close the given
     * InputStream.  If the current file type is ASCII, line separators in
     * the file are transparently converted to the NETASCII format (i.e.,
     * you should not attempt to create a special InputStream to do this).
     *
     * @param local   The local InputStream from which to read the file.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws org.apache.commons.net.io.CopyStreamException
     *      If an I/O error occurs while actually
     *      transferring the file.  The CopyStreamException allows you to
     *      determine the number of bytes transferred and the IOException
     *      causing the error.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean storeUniqueFile(InputStream local) throws IOException
    {
<span class="nc" id="L2225">        return __storeFile(FTPCmd.STOU, null, local);</span>
    }

    /**
     * Returns an OutputStream through which data can be written to store
     * a file on the server using a unique name assigned by the server.
     * If the current file type
     * is ASCII, the returned OutputStream will convert line separators in
     * the file to the NETASCII format  (i.e., you should not attempt to
     * create a special OutputStream to do this).  You must close the
     * OutputStream when you finish writing to it.  The OutputStream itself
     * will take care of closing the parent data connection socket upon being
     * closed.
     * &lt;p&gt;
     * &lt;b&gt;To finalize the file transfer you must call
     * {@link #completePendingCommand  completePendingCommand } and
     * check its return value to verify success.&lt;/b&gt;
     * If this is not done, subsequent commands may behave unexpectedly.
     *
     * @return An OutputStream through which the remote file can be written.  If
     *      the data connection cannot be opened (e.g., the file does not
     *      exist), null is returned (in which case you may check the reply
     *      code to determine the exact reason for failure).
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public OutputStream storeUniqueFileStream() throws IOException
    {
<span class="nc" id="L2258">        return __storeFileStream(FTPCmd.STOU, null);</span>
    }

    /**
     * Reserve a number of bytes on the server for the next file transfer.
     *
     * @param bytes  The number of bytes which the server should allocate.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean allocate(int bytes) throws IOException
    {
<span class="nc" id="L2276">        return FTPReply.isPositiveCompletion(allo(bytes));</span>
    }

    /**
     * Query the server for supported features. The server may reply with a list of server-supported exensions.
     * For example, a typical client-server interaction might be (from RFC 2389):
     * &lt;pre&gt;
        C&amp;gt; feat
        S&amp;gt; 211-Extensions supported:
        S&amp;gt;  MLST size*;create;modify*;perm;media-type
        S&amp;gt;  SIZE
        S&amp;gt;  COMPRESSION
        S&amp;gt;  MDTM
        S&amp;gt; 211 END
     * &lt;/pre&gt;
     * @see &lt;a href=&quot;http://www.faqs.org/rfcs/rfc2389.html&quot;&gt;http://www.faqs.org/rfcs/rfc2389.html&lt;/a&gt;
     * @return True if successfully completed, false if not.
     * @throws IOException on error
     * @since 2.2
     */
    public boolean features() throws IOException {
<span class="nc" id="L2297">        return FTPReply.isPositiveCompletion(feat());</span>
    }

    /**
     * Query the server for a supported feature, and returns its values (if any).
     * Caches the parsed response to avoid resending the command repeatedly.
     * @param feature the feature to check
     *
     * @return if the feature is present, returns the feature values (empty array if none)
     * Returns {@code null} if the feature is not found or the command failed.
     * Check {@link #getReplyCode()} or {@link #getReplyString()} if so.
     * @throws IOException on error
     * @since 3.0
     */
    public String[] featureValues(String feature) throws IOException {
<span class="nc bnc" id="L2312" title="All 2 branches missed.">        if (!initFeatureMap()) {</span>
<span class="nc" id="L2313">            return null;</span>
        }
<span class="nc" id="L2315">        Set&lt;String&gt; entries = __featuresMap.get(feature.toUpperCase(Locale.ENGLISH));</span>
<span class="nc bnc" id="L2316" title="All 2 branches missed.">        if (entries != null) {</span>
<span class="nc" id="L2317">            return entries.toArray(new String[entries.size()]);</span>
        }
<span class="nc" id="L2319">        return null;</span>
    }

    /**
     * Query the server for a supported feature, and returns the its value (if any).
     * Caches the parsed response to avoid resending the command repeatedly.
     * @param feature the feature to check
     *
     * @return if the feature is present, returns the feature value or the empty string
     * if the feature exists but has no value.
     * Returns {@code null} if the feature is not found or the command failed.
     * Check {@link #getReplyCode()} or {@link #getReplyString()} if so.
     * @throws IOException on error
     * @since 3.0
     */
    public String featureValue(String feature) throws IOException {
<span class="nc" id="L2335">        String [] values = featureValues(feature);</span>
<span class="nc bnc" id="L2336" title="All 2 branches missed.">        if (values != null) {</span>
<span class="nc" id="L2337">            return values[0];</span>
        }
<span class="nc" id="L2339">        return null;</span>
    }

    /**
     * Query the server for a supported feature.
     * Caches the parsed response to avoid resending the command repeatedly.
     *
     * @param feature the name of the feature; it is converted to upper case.
     * @return {@code true} if the feature is present, {@code false} if the feature is not present
     * or the {@link #feat()} command failed. Check {@link #getReplyCode()} or {@link #getReplyString()}
     * if it is necessary to distinguish these cases.
     *
     * @throws IOException on error
     * @since 3.0
     */
    public boolean hasFeature(String feature) throws IOException {
<span class="nc bnc" id="L2355" title="All 2 branches missed.">        if (!initFeatureMap()) {</span>
<span class="nc" id="L2356">            return false;</span>
        }
<span class="nc" id="L2358">        return __featuresMap.containsKey(feature.toUpperCase(Locale.ENGLISH));</span>
    }

    /**
     * Query the server for a supported feature with particular value,
     * for example &quot;AUTH SSL&quot; or &quot;AUTH TLS&quot;.
     * Caches the parsed response to avoid resending the command repeatedly.
     *
     * @param feature the name of the feature; it is converted to upper case.
     * @param value the value to find.
     *
     * @return {@code true} if the feature is present, {@code false} if the feature is not present
     * or the {@link #feat()} command failed. Check {@link #getReplyCode()} or {@link #getReplyString()}
     * if it is necessary to distinguish these cases.
     *
     * @throws IOException on error
     * @since 3.0
     */
    public boolean hasFeature(String feature, String value) throws IOException {
<span class="nc bnc" id="L2377" title="All 2 branches missed.">        if (!initFeatureMap()) {</span>
<span class="nc" id="L2378">            return false;</span>
        }
<span class="nc" id="L2380">        Set&lt;String&gt; entries = __featuresMap.get(feature.toUpperCase(Locale.ENGLISH));</span>
<span class="nc bnc" id="L2381" title="All 2 branches missed.">        if (entries != null) {</span>
<span class="nc" id="L2382">            return entries.contains(value);</span>
        }
<span class="nc" id="L2384">        return false;</span>
    }

    /*
     * Create the feature map if not already created.
     */
    private boolean initFeatureMap() throws IOException {
<span class="nc bnc" id="L2391" title="All 2 branches missed.">        if (__featuresMap == null) {</span>
            // Don't create map here, because next line may throw exception
<span class="nc" id="L2393">            final int replyCode = feat();</span>
<span class="nc bnc" id="L2394" title="All 2 branches missed.">            if (replyCode == FTPReply.NOT_LOGGED_IN) { // 503</span>
<span class="nc" id="L2395">                return false; // NET-518; don't create empy map</span>
            }
<span class="nc" id="L2397">            boolean success = FTPReply.isPositiveCompletion(replyCode);</span>
            // we init the map here, so we don't keep trying if we know the command will fail
<span class="nc" id="L2399">            __featuresMap = new HashMap&lt;String, Set&lt;String&gt;&gt;();</span>
<span class="nc bnc" id="L2400" title="All 2 branches missed.">            if (!success) {</span>
<span class="nc" id="L2401">                return false;</span>
            }
<span class="nc bnc" id="L2403" title="All 2 branches missed.">            for (String l : getReplyStrings()) {</span>
<span class="nc bnc" id="L2404" title="All 2 branches missed.">                if (l.startsWith(&quot; &quot;)) { // it's a FEAT entry</span>
                    String key;
<span class="nc" id="L2406">                    String value=&quot;&quot;;</span>
<span class="nc" id="L2407">                    int varsep = l.indexOf(' ', 1);</span>
<span class="nc bnc" id="L2408" title="All 2 branches missed.">                    if (varsep &gt; 0) {</span>
<span class="nc" id="L2409">                        key = l.substring(1, varsep);</span>
<span class="nc" id="L2410">                        value = l.substring(varsep+1);</span>
                    } else {
<span class="nc" id="L2412">                        key = l.substring(1);</span>
                    }
<span class="nc" id="L2414">                    key = key.toUpperCase(Locale.ENGLISH);</span>
<span class="nc" id="L2415">                    Set&lt;String&gt; entries = __featuresMap.get(key);</span>
<span class="nc bnc" id="L2416" title="All 2 branches missed.">                    if (entries == null) {</span>
<span class="nc" id="L2417">                        entries = new HashSet&lt;String&gt;();</span>
<span class="nc" id="L2418">                        __featuresMap.put(key, entries);</span>
                    }
<span class="nc" id="L2420">                    entries.add(value);</span>
                }
            }
        }
<span class="nc" id="L2424">        return true;</span>
    }

    /**
     * Reserve space on the server for the next file transfer.
     *
     * @param bytes  The number of bytes which the server should allocate.
     * @param recordSize  The size of a file record.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean allocate(int bytes, int recordSize) throws IOException
    {
<span class="nc" id="L2443">        return FTPReply.isPositiveCompletion(allo(bytes, recordSize));</span>
    }


    /**
     * Issue a command and wait for the reply.
     * &lt;p&gt;
     * Should only be used with commands that return replies on the
     * command channel - do not use for LIST, NLST, MLSD etc.
     *
     * @param command  The command to invoke
     * @param params  The parameters string, may be {@code null}
     * @return True if successfully completed, false if not, in which case
     * call {@link #getReplyCode()} or {@link #getReplyString()}
     * to get the reason.
     *
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     * @since 3.0
     */
    public boolean doCommand(String command, String params) throws IOException
    {
<span class="nc" id="L2465">        return FTPReply.isPositiveCompletion(sendCommand(command, params));</span>
    }

    /**
     * Issue a command and wait for the reply, returning it as an array of strings.
     * &lt;p&gt;
     * Should only be used with commands that return replies on the
     * command channel - do not use for LIST, NLST, MLSD etc.
     *
     * @param command  The command to invoke
     * @param params  The parameters string, may be {@code null}
     * @return The array of replies, or {@code null} if the command failed, in which case
     * call {@link #getReplyCode()} or {@link #getReplyString()}
     * to get the reason.
     *
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     * @since 3.0
     */
    public String[] doCommandAsStrings(String command, String params) throws IOException
    {
<span class="nc" id="L2486">        boolean success = FTPReply.isPositiveCompletion(sendCommand(command, params));</span>
<span class="nc bnc" id="L2487" title="All 2 branches missed.">        if (success){</span>
<span class="nc" id="L2488">            return getReplyStrings();</span>
        } else {
<span class="nc" id="L2490">            return null;</span>
        }
    }

    /**
     * Get file details using the MLST command
     *
     * @param pathname the file or directory to list, may be {@code null}
     * @return the file details, may be {@code null}
     * @throws IOException on error
     * @since 3.0
     */
    public FTPFile mlistFile(String pathname) throws IOException
    {
<span class="nc" id="L2504">        boolean success = FTPReply.isPositiveCompletion(sendCommand(FTPCmd.MLST, pathname));</span>
<span class="nc bnc" id="L2505" title="All 2 branches missed.">        if (success){</span>
<span class="nc" id="L2506">            String reply = getReplyStrings()[1];</span>
            /* check the response makes sense.
             * Must have space before fact(s) and between fact(s) and filename
             * Fact(s) can be absent, so at least 3 chars are needed.
             */
<span class="nc bnc" id="L2511" title="All 4 branches missed.">            if (reply.length() &lt; 3 || reply.charAt(0) != ' ') {</span>
<span class="nc" id="L2512">                throw new MalformedServerReplyException(&quot;Invalid server reply (MLST): '&quot; + reply + &quot;'&quot;);</span>
            }
<span class="nc" id="L2514">            String entry = reply.substring(1); // skip leading space for parser</span>
<span class="nc" id="L2515">            return MLSxEntryParser.parseEntry(entry);</span>
        } else {
<span class="nc" id="L2517">            return null;</span>
        }
    }

    /**
     * Generate a directory listing for the current directory using the MLSD command.
     *
     * @return the array of file entries
     * @throws IOException on error
     * @since 3.0
     */
    public FTPFile[] mlistDir() throws IOException
    {
<span class="nc" id="L2530">        return mlistDir(null);</span>
    }

    /**
     * Generate a directory listing using the MLSD command.
     *
     * @param pathname the directory name, may be {@code null}
     * @return the array of file entries
     * @throws IOException on error
     * @since 3.0
     */
    public FTPFile[] mlistDir(String pathname) throws IOException
    {
<span class="nc" id="L2543">        FTPListParseEngine engine = initiateMListParsing( pathname);</span>
<span class="nc" id="L2544">        return engine.getFiles();</span>
    }

    /**
     * Generate a directory listing using the MLSD command.
     *
     * @param pathname the directory name, may be {@code null}
     * @param filter the filter to apply to the responses
     * @return the array of file entries
     * @throws IOException on error
     * @since 3.0
     */
    public FTPFile[] mlistDir(String pathname, FTPFileFilter filter) throws IOException
    {
<span class="nc" id="L2558">        FTPListParseEngine engine = initiateMListParsing( pathname);</span>
<span class="nc" id="L2559">        return engine.getFiles(filter);</span>
    }

    /**
     * Restart a &lt;code&gt;STREAM_TRANSFER_MODE&lt;/code&gt; file transfer starting
     * from the given offset.  This will only work on FTP servers supporting
     * the REST comand for the stream transfer mode.  However, most FTP
     * servers support this.  Any subsequent file transfer will start
     * reading or writing the remote file from the indicated offset.
     *
     * @param offset  The offset into the remote file at which to start the
     *           next file transfer.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     * @since 3.1 (changed from private to protected)
     */
    protected boolean restart(long offset) throws IOException
    {
<span class="nc" id="L2583">        __restartOffset = 0;</span>
<span class="nc" id="L2584">        return FTPReply.isPositiveIntermediate(rest(Long.toString(offset)));</span>
    }

    /**
     * Sets the restart offset for file transfers.
     * &lt;p&gt;
     * The restart command is not sent to the server immediately.
     * It is sent when a data connection is created as part of a
     * subsequent command.
     * The restart marker is reset to zero after use.
     * &lt;/p&gt;
     * &lt;p&gt;
     * &lt;b&gt;Note: This method should only be invoked immediately prior to
     * the transfer to which it applies.&lt;/b&gt;
     *
     * @param offset  The offset into the remote file at which to start the
     *           next file transfer.  This must be a value greater than or
     *           equal to zero.
     */
    public void setRestartOffset(long offset)
    {
<span class="nc bnc" id="L2605" title="All 2 branches missed.">        if (offset &gt;= 0) {</span>
<span class="nc" id="L2606">            __restartOffset = offset;</span>
        }
<span class="nc" id="L2608">    }</span>

    /**
     * Fetches the restart offset.
     *
     * @return offset  The offset into the remote file at which to start the
     *           next file transfer.
     */
    public long getRestartOffset()
    {
<span class="nc" id="L2618">        return __restartOffset;</span>
    }



    /**
     * Renames a remote file.
     *
     * @param from  The name of the remote file to rename.
     * @param to    The new name of the remote file.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean rename(String from, String to) throws IOException
    {
<span class="nc bnc" id="L2639" title="All 2 branches missed.">        if (!FTPReply.isPositiveIntermediate(rnfr(from))) {</span>
<span class="nc" id="L2640">            return false;</span>
        }

<span class="nc" id="L2643">        return FTPReply.isPositiveCompletion(rnto(to));</span>
    }


    /**
     * Abort a transfer in progress.
     *
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean abort() throws IOException
    {
<span class="nc" id="L2661">        return FTPReply.isPositiveCompletion(abor());</span>
    }

    /**
     * Deletes a file on the FTP server.
     *
     * @param pathname   The pathname of the file to be deleted.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean deleteFile(String pathname) throws IOException
    {
<span class="nc" id="L2679">        return FTPReply.isPositiveCompletion(dele(pathname));</span>
    }


    /**
     * Removes a directory on the FTP server (if empty).
     *
     * @param pathname  The pathname of the directory to remove.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean removeDirectory(String pathname) throws IOException
    {
<span class="nc" id="L2698">        return FTPReply.isPositiveCompletion(rmd(pathname));</span>
    }


    /**
     * Creates a new subdirectory on the FTP server in the current directory
     * (if a relative pathname is given) or where specified (if an absolute
     * pathname is given).
     *
     * @param pathname The pathname of the directory to create.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean makeDirectory(String pathname) throws IOException
    {
<span class="nc" id="L2719">        return FTPReply.isPositiveCompletion(mkd(pathname));</span>
    }


    /**
     * Returns the pathname of the current working directory.
     *
     * @return The pathname of the current working directory.  If it cannot
     *         be obtained, returns null.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public String printWorkingDirectory() throws IOException
    {
<span class="nc bnc" id="L2738" title="All 2 branches missed.">        if (pwd() != FTPReply.PATHNAME_CREATED) {</span>
<span class="nc" id="L2739">            return null;</span>
        }

<span class="nc" id="L2742">        return __parsePathname(_replyLines.get( _replyLines.size() - 1));</span>
    }


    /**
     * Send a site specific command.
     * @param arguments The site specific command and arguments.
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean sendSiteCommand(String arguments) throws IOException
    {
<span class="nc" id="L2760">        return FTPReply.isPositiveCompletion(site(arguments));</span>
    }


    /**
     * Fetches the system type from the server and returns the string.
     * This value is cached for the duration of the connection after the
     * first call to this method.  In other words, only the first time
     * that you invoke this method will it issue a SYST command to the
     * FTP server.  FTPClient will remember the value and return the
     * cached value until a call to disconnect.
     * &lt;p&gt;
     * If the SYST command fails, and the system property
     * {@link #FTP_SYSTEM_TYPE_DEFAULT} is defined, then this is used instead.
     * @return The system type obtained from the server. Never null.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *  command to the server or receiving a reply from the server (and the default
     *  system type property is not defined)
     *  @since 2.2
     */
    public String getSystemType() throws IOException
    {
        //if (syst() == FTPReply.NAME_SYSTEM_TYPE)
        // Technically, we should expect a NAME_SYSTEM_TYPE response, but
        // in practice FTP servers deviate, so we soften the condition to
        // a positive completion.
<span class="nc bnc" id="L2791" title="All 2 branches missed.">        if (__systemName == null){</span>
<span class="nc bnc" id="L2792" title="All 2 branches missed.">            if (FTPReply.isPositiveCompletion(syst())) {</span>
                // Assume that response is not empty here (cannot be null)
<span class="nc" id="L2794">                __systemName = _replyLines.get(_replyLines.size() - 1).substring(4);</span>
            } else {
                // Check if the user has provided a default for when the SYST command fails
<span class="nc" id="L2797">                String systDefault = System.getProperty(FTP_SYSTEM_TYPE_DEFAULT);</span>
<span class="nc bnc" id="L2798" title="All 2 branches missed.">                if (systDefault != null) {</span>
<span class="nc" id="L2799">                    __systemName = systDefault;</span>
                } else {
<span class="nc" id="L2801">                    throw new IOException(&quot;Unable to determine system type - response: &quot; + getReplyString());</span>
                }
            }
        }
<span class="nc" id="L2805">        return __systemName;</span>
    }


    /**
     * Fetches the system help information from the server and returns the
     * full string.
     *
     * @return The system help string obtained from the server.  null if the
     *       information could not be obtained.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *  command to the server or receiving a reply from the server.
     */
    public String listHelp() throws IOException
    {
<span class="nc bnc" id="L2825" title="All 2 branches missed.">        if (FTPReply.isPositiveCompletion(help())) {</span>
<span class="nc" id="L2826">            return getReplyString();</span>
        }
<span class="nc" id="L2828">        return null;</span>
    }


    /**
     * Fetches the help information for a given command from the server and
     * returns the full string.
     * @param command The command on which to ask for help.
     * @return The command help string obtained from the server.  null if the
     *       information could not be obtained.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *  command to the server or receiving a reply from the server.
     */
    public String listHelp(String command) throws IOException
    {
<span class="nc bnc" id="L2848" title="All 2 branches missed.">        if (FTPReply.isPositiveCompletion(help(command))) {</span>
<span class="nc" id="L2849">            return getReplyString();</span>
        }
<span class="nc" id="L2851">        return null;</span>
    }


    /**
     * Sends a NOOP command to the FTP server.  This is useful for preventing
     * server timeouts.
     *
     * @return True if successfully completed, false if not.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public boolean sendNoOp() throws IOException
    {
<span class="nc" id="L2870">        return FTPReply.isPositiveCompletion(noop());</span>
    }


    /**
     * Obtain a list of filenames in a directory (or just the name of a given
     * file, which is not particularly useful).  This information is obtained
     * through the NLST command.  If the given pathname is a directory and
     * contains no files,  a zero length array is returned only
     * if the FTP server returned a positive completion code, otherwise
     * null is returned (the FTP server returned a 550 error No files found.).
     * If the directory is not empty, an array of filenames in the directory is
     * returned. If the pathname corresponds
     * to a file, only that file will be listed.  The server may or may not
     * expand glob expressions.
     *
     * @param pathname  The file or directory to list.
     *                  Warning: the server may treat a leading '-' as an
     *                  option introducer. If so, try using an absolute path,
     *                  or prefix the path with ./ (unix style servers).
     *                  Some servers may support &quot;--&quot; as meaning end of options,
     *                  in which case &quot;-- -xyz&quot; should work.
     * @return The list of filenames contained in the given path.  null if
     *     the list could not be obtained.  If there are no filenames in
     *     the directory, a zero-length array is returned.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public String[] listNames(String pathname) throws IOException
    {
<span class="nc" id="L2905">        Socket socket = _openDataConnection_(FTPCmd.NLST, getListArguments(pathname));</span>

<span class="nc bnc" id="L2907" title="All 2 branches missed.">        if (socket == null) {</span>
<span class="nc" id="L2908">            return null;</span>
        }

<span class="nc" id="L2911">        BufferedReader reader =</span>
<span class="nc" id="L2912">            new BufferedReader(new InputStreamReader(socket.getInputStream(), getControlEncoding()));</span>

<span class="nc" id="L2914">        ArrayList&lt;String&gt; results = new ArrayList&lt;String&gt;();</span>
        String line;
<span class="nc bnc" id="L2916" title="All 2 branches missed.">        while ((line = reader.readLine()) != null) {</span>
<span class="nc" id="L2917">            results.add(line);</span>
        }

<span class="nc" id="L2920">        reader.close();</span>
<span class="nc" id="L2921">        socket.close();</span>

<span class="nc bnc" id="L2923" title="All 2 branches missed.">        if (completePendingCommand())</span>
        {
<span class="nc" id="L2925">            String[] names = new String[ results.size() ];</span>
<span class="nc" id="L2926">            return results.toArray(names);</span>
        }

<span class="nc" id="L2929">        return null;</span>
    }


    /**
     * Obtain a list of filenames in the current working directory
     * This information is obtained through the NLST command.  If the current
     * directory contains no files, a zero length array is returned only
     * if the FTP server returned a positive completion code, otherwise,
     * null is returned (the FTP server returned a 550 error No files found.).
     * If the directory is not empty, an array of filenames in the directory is
     * returned.
     *
     * @return The list of filenames contained in the current working
     *     directory.  null if the list could not be obtained.
     *     If there are no filenames in the directory, a zero-length array
     *     is returned.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public String[] listNames() throws IOException
    {
<span class="nc" id="L2956">        return listNames(null);</span>
    }



    /**
     * Using the default system autodetect mechanism, obtain a
     * list of file information for the current working directory
     * or for just a single file.
     * &lt;p&gt;
     * This information is obtained through the LIST command.  The contents of
     * the returned array is determined by the&lt;code&gt; FTPFileEntryParser &lt;/code&gt;
     * used.
     * &lt;p&gt;
     * N.B. the LIST command does not generally return very precise timestamps.
     * For recent files, the response usually contains hours and minutes (not seconds).
     * For older files, the output may only contain a date.
     * If the server supports it, the MLSD command returns timestamps with a precision
     * of seconds, and may include milliseconds. See {@link #mlistDir()}
     *
     * @param pathname  The file or directory to list.  Since the server may
     *                  or may not expand glob expressions, using them here
     *                  is not recommended and may well cause this method to
     *                  fail.
     *                  Also, some servers treat a leading '-' as being an option.
     *                  To avoid this interpretation, use an absolute pathname
     *                  or prefix the pathname with ./ (unix style servers).
     *                  Some servers may support &quot;--&quot; as meaning end of options,
     *                  in which case &quot;-- -xyz&quot; should work.
     *
     * @return The list of file information contained in the given path in
     *         the format determined by the autodetection mechanism
     * @throws FTPConnectionClosedException
     *                   If the FTP server prematurely closes the connection
     *                   as a result of the client being idle or some other
     *                   reason causing the server to send FTP reply code 421.
     *                   This exception may be caught either as an IOException
     *                   or independently as itself.
     * @throws IOException
     *                   If an I/O error occurs while either sending a
     *                   command to the server or receiving a reply
     *                   from the server.
     * @throws org.apache.commons.net.ftp.parser.ParserInitializationException
     *                   Thrown if the parserKey parameter cannot be
     *                   resolved by the selected parser factory.
     *                   In the DefaultFTPEntryParserFactory, this will
     *                   happen when parserKey is neither
     *                   the fully qualified class name of a class
     *                   implementing the interface
     *                   org.apache.commons.net.ftp.FTPFileEntryParser
     *                   nor a string containing one of the recognized keys
     *                   mapping to such a parser or if class loader
     *                   security issues prevent its being loaded.
     * @see org.apache.commons.net.ftp.parser.DefaultFTPFileEntryParserFactory
     * @see org.apache.commons.net.ftp.parser.FTPFileEntryParserFactory
     * @see org.apache.commons.net.ftp.FTPFileEntryParser
     */
    public FTPFile[] listFiles(String pathname)
    throws IOException
    {
<span class="nc" id="L3016">        FTPListParseEngine engine = initiateListParsing((String) null, pathname);</span>
<span class="nc" id="L3017">        return engine.getFiles();</span>

    }

    /**
     * Using the default system autodetect mechanism, obtain a
     * list of file information for the current working directory.
     * &lt;p&gt;
     * This information is obtained through the LIST command.  The contents of
     * the returned array is determined by the&lt;code&gt; FTPFileEntryParser &lt;/code&gt;
     * used.
     * &lt;p&gt;
     * N.B. the LIST command does not generally return very precise timestamps.
     * For recent files, the response usually contains hours and minutes (not seconds).
     * For older files, the output may only contain a date.
     * If the server supports it, the MLSD command returns timestamps with a precision
     * of seconds, and may include milliseconds. See {@link #mlistDir()}
     *
     * @return The list of file information contained in the current directory
     *         in the format determined by the autodetection mechanism.
     *         &lt;p&gt;&lt;b&gt;
     *         NOTE:&lt;/b&gt; This array may contain null members if any of the
     *         individual file listings failed to parse.  The caller should
     *         check each entry for null before referencing it.
     * @throws FTPConnectionClosedException
     *                   If the FTP server prematurely closes the connection
     *                   as a result of the client being idle or some other
     *                   reason causing the server to send FTP reply code 421.
     *                   This exception may be caught either as an IOException
     *                   or independently as itself.
     * @throws IOException
     *                   If an I/O error occurs while either sending a
     *                   command to the server or receiving a reply
     *                   from the server.
     * @throws org.apache.commons.net.ftp.parser.ParserInitializationException
     *                   Thrown if the parserKey parameter cannot be
     *                   resolved by the selected parser factory.
     *                   In the DefaultFTPEntryParserFactory, this will
     *                   happen when parserKey is neither
     *                   the fully qualified class name of a class
     *                   implementing the interface
     *                   org.apache.commons.net.ftp.FTPFileEntryParser
     *                   nor a string containing one of the recognized keys
     *                   mapping to such a parser or if class loader
     *                   security issues prevent its being loaded.
     * @see org.apache.commons.net.ftp.parser.DefaultFTPFileEntryParserFactory
     * @see org.apache.commons.net.ftp.parser.FTPFileEntryParserFactory
     * @see org.apache.commons.net.ftp.FTPFileEntryParser
     */
    public FTPFile[] listFiles()
    throws IOException
    {
<span class="nc" id="L3069">        return listFiles((String) null);</span>
    }

    /**
     * Version of {@link #listFiles(String)} which allows a filter to be provided.
     * For example: &lt;code&gt;listFiles(&quot;site&quot;, FTPFileFilters.DIRECTORY);&lt;/code&gt;
     * @param pathname the initial path, may be null
     * @param filter the filter, non-null
     * @return the list of FTPFile entries.
     * @throws IOException on error
     * @since 2.2
     */
    public FTPFile[] listFiles(String pathname, FTPFileFilter filter)
    throws IOException
    {
<span class="nc" id="L3084">        FTPListParseEngine engine = initiateListParsing((String) null, pathname);</span>
<span class="nc" id="L3085">        return engine.getFiles(filter);</span>

    }

    /**
     * Using the default system autodetect mechanism, obtain a
     * list of directories contained in the current working directory.
     * &lt;p&gt;
     * This information is obtained through the LIST command.  The contents of
     * the returned array is determined by the&lt;code&gt; FTPFileEntryParser &lt;/code&gt;
     * used.
     * &lt;p&gt;
     * N.B. the LIST command does not generally return very precise timestamps.
     * For recent files, the response usually contains hours and minutes (not seconds).
     * For older files, the output may only contain a date.
     * If the server supports it, the MLSD command returns timestamps with a precision
     * of seconds, and may include milliseconds. See {@link #mlistDir()}
     *
     * @return The list of directories contained in the current directory
     *         in the format determined by the autodetection mechanism.
     *
     * @throws FTPConnectionClosedException
     *                   If the FTP server prematurely closes the connection
     *                   as a result of the client being idle or some other
     *                   reason causing the server to send FTP reply code 421.
     *                   This exception may be caught either as an IOException
     *                   or independently as itself.
     * @throws IOException
     *                   If an I/O error occurs while either sending a
     *                   command to the server or receiving a reply
     *                   from the server.
     * @throws org.apache.commons.net.ftp.parser.ParserInitializationException
     *                   Thrown if the parserKey parameter cannot be
     *                   resolved by the selected parser factory.
     *                   In the DefaultFTPEntryParserFactory, this will
     *                   happen when parserKey is neither
     *                   the fully qualified class name of a class
     *                   implementing the interface
     *                   org.apache.commons.net.ftp.FTPFileEntryParser
     *                   nor a string containing one of the recognized keys
     *                   mapping to such a parser or if class loader
     *                   security issues prevent its being loaded.
     * @see org.apache.commons.net.ftp.parser.DefaultFTPFileEntryParserFactory
     * @see org.apache.commons.net.ftp.parser.FTPFileEntryParserFactory
     * @see org.apache.commons.net.ftp.FTPFileEntryParser
     * @since 3.0
     */
    public FTPFile[] listDirectories() throws IOException {
<span class="nc" id="L3133">        return listDirectories((String) null);</span>
    }

    /**
     * Using the default system autodetect mechanism, obtain a
     * list of directories contained in the specified directory.
     * &lt;p&gt;
     * This information is obtained through the LIST command.  The contents of
     * the returned array is determined by the&lt;code&gt; FTPFileEntryParser &lt;/code&gt;
     * used.
     * &lt;p&gt;
     * N.B. the LIST command does not generally return very precise timestamps.
     * For recent files, the response usually contains hours and minutes (not seconds).
     * For older files, the output may only contain a date.
     * If the server supports it, the MLSD command returns timestamps with a precision
     * of seconds, and may include milliseconds. See {@link #mlistDir()}
     * @param parent the starting directory
     *
     * @return The list of directories contained in the specified directory
     *         in the format determined by the autodetection mechanism.
     *
     * @throws FTPConnectionClosedException
     *                   If the FTP server prematurely closes the connection
     *                   as a result of the client being idle or some other
     *                   reason causing the server to send FTP reply code 421.
     *                   This exception may be caught either as an IOException
     *                   or independently as itself.
     * @throws IOException
     *                   If an I/O error occurs while either sending a
     *                   command to the server or receiving a reply
     *                   from the server.
     * @throws org.apache.commons.net.ftp.parser.ParserInitializationException
     *                   Thrown if the parserKey parameter cannot be
     *                   resolved by the selected parser factory.
     *                   In the DefaultFTPEntryParserFactory, this will
     *                   happen when parserKey is neither
     *                   the fully qualified class name of a class
     *                   implementing the interface
     *                   org.apache.commons.net.ftp.FTPFileEntryParser
     *                   nor a string containing one of the recognized keys
     *                   mapping to such a parser or if class loader
     *                   security issues prevent its being loaded.
     * @see org.apache.commons.net.ftp.parser.DefaultFTPFileEntryParserFactory
     * @see org.apache.commons.net.ftp.parser.FTPFileEntryParserFactory
     * @see org.apache.commons.net.ftp.FTPFileEntryParser
     * @since 3.0
     */
    public FTPFile[] listDirectories(String parent) throws IOException {
<span class="nc" id="L3181">        return listFiles(parent, FTPFileFilters.DIRECTORIES);</span>
    }

    /**
     * Using the default autodetect mechanism, initialize an FTPListParseEngine
     * object containing a raw file information for the current working
     * directory on the server
     * This information is obtained through the LIST command.  This object
     * is then capable of being iterated to return a sequence of FTPFile
     * objects with information filled in by the
     * &lt;code&gt; FTPFileEntryParser &lt;/code&gt; used.
     * &lt;p&gt;
     * This method differs from using the listFiles() methods in that
     * expensive FTPFile objects are not created until needed which may be
     * an advantage on large lists.
     *
     * @return A FTPListParseEngine object that holds the raw information and
     * is capable of providing parsed FTPFile objects, one for each file
     * containing information contained in the given path in the format
     * determined by the &lt;code&gt; parser &lt;/code&gt; parameter.   Null will be
     * returned if a data connection cannot be opened.  If the current working
     * directory contains no files, an empty array will be the return.
     *
     * @throws FTPConnectionClosedException
     *                   If the FTP server prematurely closes the connection as a result
     *                   of the client being idle or some other reason causing the server
     *                   to send FTP reply code 421.  This exception may be caught either
     *                   as an IOException or independently as itself.
     * @throws IOException
     *                   If an I/O error occurs while either sending a
     *                   command to the server or receiving a reply from the server.
     * @throws org.apache.commons.net.ftp.parser.ParserInitializationException
     *                   Thrown if the autodetect mechanism cannot
     *                   resolve the type of system we are connected with.
     * @see FTPListParseEngine
     */
    public FTPListParseEngine initiateListParsing()
    throws IOException
    {
<span class="nc" id="L3220">        return initiateListParsing((String) null);</span>
    }

    /**
     * Using the default autodetect mechanism, initialize an FTPListParseEngine
     * object containing a raw file information for the supplied directory.
     * This information is obtained through the LIST command.  This object
     * is then capable of being iterated to return a sequence of FTPFile
     * objects with information filled in by the
     * &lt;code&gt; FTPFileEntryParser &lt;/code&gt; used.
     * &lt;p&gt;
     * The server may or may not expand glob expressions.  You should avoid
     * using glob expressions because the return format for glob listings
     * differs from server to server and will likely cause this method to fail.
     * &lt;p&gt;
     * This method differs from using the listFiles() methods in that
     * expensive FTPFile objects are not created until needed which may be
     * an advantage on large lists.
     *
     * &lt;pre&gt;
     *    FTPClient f=FTPClient();
     *    f.connect(server);
     *    f.login(username, password);
     *    FTPListParseEngine engine = f.initiateListParsing(directory);
     *
     *    while (engine.hasNext()) {
     *       FTPFile[] files = engine.getNext(25);  // &quot;page size&quot; you want
     *       //do whatever you want with these files, display them, etc.
     *       //expensive FTPFile objects not created until needed.
     *    }
     * &lt;/pre&gt;
     * @param pathname the starting directory
     *
     * @return A FTPListParseEngine object that holds the raw information and
     * is capable of providing parsed FTPFile objects, one for each file
     * containing information contained in the given path in the format
     * determined by the &lt;code&gt; parser &lt;/code&gt; parameter.   Null will be
     * returned if a data connection cannot be opened.  If the current working
     * directory contains no files, an empty array will be the return.
     *
     * @throws FTPConnectionClosedException
     *                   If the FTP server prematurely closes the connection as a result
     *                   of the client being idle or some other reason causing the server
     *                   to send FTP reply code 421.  This exception may be caught either
     *                   as an IOException or independently as itself.
     * @throws IOException
     *                   If an I/O error occurs while either sending a
     *                   command to the server or receiving a reply from the server.
     * @throws org.apache.commons.net.ftp.parser.ParserInitializationException
     *                   Thrown if the autodetect mechanism cannot
     *                   resolve the type of system we are connected with.
     * @see FTPListParseEngine
     */
    public FTPListParseEngine initiateListParsing(String pathname)
    throws IOException
    {
<span class="nc" id="L3276">        return initiateListParsing((String) null, pathname);</span>
    }

    /**
     * Using the supplied parser key, initialize an FTPListParseEngine
     * object containing a raw file information for the supplied directory.
     * This information is obtained through the LIST command.  This object
     * is then capable of being iterated to return a sequence of FTPFile
     * objects with information filled in by the
     * &lt;code&gt; FTPFileEntryParser &lt;/code&gt; used.
     * &lt;p&gt;
     * The server may or may not expand glob expressions.  You should avoid
     * using glob expressions because the return format for glob listings
     * differs from server to server and will likely cause this method to fail.
     * &lt;p&gt;
     * This method differs from using the listFiles() methods in that
     * expensive FTPFile objects are not created until needed which may be
     * an advantage on large lists.
     *
     * @param parserKey A string representing a designated code or fully-qualified
     * class name of an  &lt;code&gt; FTPFileEntryParser &lt;/code&gt; that should be
     *               used to parse each server file listing.
     *               May be {@code null}, in which case the code checks first
     *               the system property {@link #FTP_SYSTEM_TYPE}, and if that is
     *               not defined the SYST command is used to provide the value.
     *               To allow for arbitrary system types, the return from the
     *               SYST command is used to look up an alias for the type in the
     *               {@link #SYSTEM_TYPE_PROPERTIES} properties file if it is available.
     * @param pathname the starting directory
     *
     * @return A FTPListParseEngine object that holds the raw information and
     * is capable of providing parsed FTPFile objects, one for each file
     * containing information contained in the given path in the format
     * determined by the &lt;code&gt; parser &lt;/code&gt; parameter.   Null will be
     * returned if a data connection cannot be opened.  If the current working
     * directory contains no files, an empty array will be the return.
     *
     * @throws FTPConnectionClosedException
     *                   If the FTP server prematurely closes the connection as a result
     *                   of the client being idle or some other reason causing the server
     *                   to send FTP reply code 421.  This exception may be caught either
     *                   as an IOException or independently as itself.
     * @throws IOException
     *                   If an I/O error occurs while either sending a
     *                   command to the server or receiving a reply from the server.
     * @throws org.apache.commons.net.ftp.parser.ParserInitializationException
     *                   Thrown if the parserKey parameter cannot be
     *                   resolved by the selected parser factory.
     *                   In the DefaultFTPEntryParserFactory, this will
     *                   happen when parserKey is neither
     *                   the fully qualified class name of a class
     *                   implementing the interface
     *                   org.apache.commons.net.ftp.FTPFileEntryParser
     *                   nor a string containing one of the recognized keys
     *                   mapping to such a parser or if class loader
     *                   security issues prevent its being loaded.
     * @see FTPListParseEngine
     */
    public FTPListParseEngine initiateListParsing(
            String parserKey, String pathname)
    throws IOException
    {
<span class="nc" id="L3338">        __createParser(parserKey); // create and cache parser</span>
<span class="nc" id="L3339">        return initiateListParsing(__entryParser, pathname);</span>
    }

    // package access for test purposes
    void __createParser(String parserKey) throws IOException {
        // We cache the value to avoid creation of a new object every
        // time a file listing is generated.
        // Note: we don't check against a null parserKey (NET-544)
<span class="fc bfc" id="L3347" title="All 6 branches covered.">        if(__entryParser == null ||  (parserKey != null &amp;&amp; ! __entryParserKey.equals(parserKey))) {</span>
<span class="fc bfc" id="L3348" title="All 2 branches covered.">            if (null != parserKey) {</span>
                // if a parser key was supplied in the parameters,
                // use that to create the parser
<span class="fc" id="L3351">                __entryParser =</span>
<span class="fc" id="L3352">                    __parserFactory.createFileEntryParser(parserKey);</span>
<span class="fc" id="L3353">                __entryParserKey = parserKey;</span>

            } else {
                // if no parserKey was supplied, check for a configuration
                // in the params, and if it has a non-empty system type, use that.
<span class="pc bpc" id="L3358" title="3 of 4 branches missed.">                if (null != __configuration &amp;&amp; __configuration.getServerSystemKey().length() &gt; 0) {</span>
<span class="nc" id="L3359">                    __entryParser =</span>
<span class="nc" id="L3360">                        __parserFactory.createFileEntryParser(__configuration);</span>
<span class="nc" id="L3361">                    __entryParserKey = __configuration.getServerSystemKey();</span>
                } else {
                    // if a parserKey hasn't been supplied, and a configuration
                    // hasn't been supplied, and the override property is not set
                    // then autodetect by calling
                    // the SYST command and use that to choose the parser.
<span class="fc" id="L3367">                    String systemType = System.getProperty(FTP_SYSTEM_TYPE);</span>
<span class="pc bpc" id="L3368" title="1 of 2 branches missed.">                    if (systemType == null) {</span>
<span class="fc" id="L3369">                        systemType = getSystemType(); // cannot be null</span>
<span class="fc" id="L3370">                        Properties override = getOverrideProperties();</span>
<span class="pc bpc" id="L3371" title="1 of 2 branches missed.">                        if (override != null) {</span>
<span class="nc" id="L3372">                            String newType = override.getProperty(systemType);</span>
<span class="nc bnc" id="L3373" title="All 2 branches missed.">                            if (newType != null) {</span>
<span class="nc" id="L3374">                                systemType = newType;</span>
                            }
                        }
                    }
<span class="pc bpc" id="L3378" title="1 of 2 branches missed.">                    if (null != __configuration) { // system type must have been empty above</span>
<span class="nc" id="L3379">                        __entryParser = __parserFactory.createFileEntryParser(new FTPClientConfig(systemType, __configuration));</span>
                    } else {
<span class="fc" id="L3381">                        __entryParser = __parserFactory.createFileEntryParser(systemType);</span>
                    }
<span class="fc" id="L3383">                    __entryParserKey = systemType;</span>
                }
            }
        }


<span class="fc" id="L3389">    }</span>

    /**
     * private method through which all listFiles() and
     * initiateListParsing methods pass once a parser is determined.
     *
     * @throws FTPConnectionClosedException
     *                   If the FTP server prematurely closes the connection as a result
     *                   of the client being idle or some other reason causing the server
     *                   to send FTP reply code 421.  This exception may be caught either
     *                   as an IOException or independently as itself.
     * @throws IOException
     *                   If an I/O error occurs while either sending a
     *                   command to the server or receiving a reply from the server.
     * @see FTPListParseEngine
     */
    private FTPListParseEngine initiateListParsing(
            FTPFileEntryParser parser, String pathname)
    throws IOException
    {
<span class="nc" id="L3409">        Socket socket = _openDataConnection_(FTPCmd.LIST, getListArguments(pathname));</span>

<span class="nc" id="L3411">        FTPListParseEngine engine = new FTPListParseEngine(parser, __configuration);</span>
<span class="nc bnc" id="L3412" title="All 2 branches missed.">        if (socket == null)</span>
        {
<span class="nc" id="L3414">            return engine;</span>
        }

        try {
<span class="nc" id="L3418">            engine.readServerList(socket.getInputStream(), getControlEncoding());</span>
        }
        finally {
<span class="nc" id="L3421">            Util.closeQuietly(socket);</span>
        }

<span class="nc" id="L3424">        completePendingCommand();</span>
<span class="nc" id="L3425">        return engine;</span>
    }

    /**
     * Initiate list parsing for MLSD listings.
     *
     * @param pathname
     * @return the engine
     * @throws IOException
     */
    private FTPListParseEngine initiateMListParsing(String pathname) throws IOException
    {
<span class="nc" id="L3437">        Socket socket = _openDataConnection_(FTPCmd.MLSD, pathname);</span>
<span class="nc" id="L3438">        FTPListParseEngine engine = new FTPListParseEngine(MLSxEntryParser.getInstance(), __configuration);</span>
<span class="nc bnc" id="L3439" title="All 2 branches missed.">        if (socket == null)</span>
        {
<span class="nc" id="L3441">            return engine;</span>
        }

        try {
<span class="nc" id="L3445">            engine.readServerList(socket.getInputStream(), getControlEncoding());</span>
        }
        finally {
<span class="nc" id="L3448">            Util.closeQuietly(socket);</span>
<span class="nc" id="L3449">            completePendingCommand();</span>
        }
<span class="nc" id="L3451">        return engine;</span>
    }

    /**
     * @param pathname the initial pathname
     * @return the adjusted string with &quot;-a&quot; added if necessary
     * @since 2.0
     */
    protected String getListArguments(String pathname) {
<span class="nc bnc" id="L3460" title="All 2 branches missed.">        if (getListHiddenFiles())</span>
        {
<span class="nc bnc" id="L3462" title="All 2 branches missed.">            if (pathname != null)</span>
            {
<span class="nc" id="L3464">                StringBuilder sb = new StringBuilder(pathname.length() + 3);</span>
<span class="nc" id="L3465">                sb.append(&quot;-a &quot;);</span>
<span class="nc" id="L3466">                sb.append(pathname);</span>
<span class="nc" id="L3467">                return sb.toString();</span>
            }
            else
            {
<span class="nc" id="L3471">                return &quot;-a&quot;;</span>
            }
        }

<span class="nc" id="L3475">        return pathname;</span>
    }


    /**
     * Issue the FTP STAT command to the server.
     *
     * @return The status information returned by the server.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public String getStatus() throws IOException
    {
<span class="nc bnc" id="L3493" title="All 2 branches missed.">        if (FTPReply.isPositiveCompletion(stat())) {</span>
<span class="nc" id="L3494">            return getReplyString();</span>
        }
<span class="nc" id="L3496">        return null;</span>
    }


    /**
     * Issue the FTP STAT command to the server for a given pathname.  This
     * should produce a listing of the file or directory.
     * @param pathname the filename
     *
     * @return The status information returned by the server.
     * @throws FTPConnectionClosedException
     *      If the FTP server prematurely closes the connection as a result
     *      of the client being idle or some other reason causing the server
     *      to send FTP reply code 421.  This exception may be caught either
     *      as an IOException or independently as itself.
     * @throws IOException  If an I/O error occurs while either sending a
     *      command to the server or receiving a reply from the server.
     */
    public String getStatus(String pathname) throws IOException
    {
<span class="nc bnc" id="L3516" title="All 2 branches missed.">        if (FTPReply.isPositiveCompletion(stat(pathname))) {</span>
<span class="nc" id="L3517">            return getReplyString();</span>
        }
<span class="nc" id="L3519">        return null;</span>
    }


    /**
     * Issue the FTP MDTM command (not supported by all servers) to retrieve the last
     * modification time of a file. The modification string should be in the
     * ISO 3077 form &quot;YYYYMMDDhhmmss(.xxx)?&quot;. The timestamp represented should also be in
     * GMT, but not all FTP servers honour this.
     *
     * @param pathname The file path to query.
     * @return A string representing the last file modification time in &lt;code&gt;YYYYMMDDhhmmss&lt;/code&gt; format.
     * @throws IOException if an I/O error occurs.
     * @since 2.0
     */
    public String getModificationTime(String pathname) throws IOException {
<span class="nc bnc" id="L3535" title="All 2 branches missed.">        if (FTPReply.isPositiveCompletion(mdtm(pathname))) {</span>
<span class="nc" id="L3536">            return getReplyStrings()[0].substring(4); // skip the return code (e.g. 213) and the space</span>
        }
<span class="nc" id="L3538">        return null;</span>
    }


    /**
     * Issue the FTP MDTM command (not supported by all servers) to retrieve the last
     * modification time of a file. The modification string should be in the
     * ISO 3077 form &quot;YYYYMMDDhhmmss(.xxx)?&quot;. The timestamp represented should also be in
     * GMT, but not all FTP servers honour this.
     *
     * @param pathname The file path to query.
     * @return A FTPFile representing the last file modification time, may be {@code null}.
     * The FTPFile timestamp will be null if a parse error occurs.
     * @throws IOException if an I/O error occurs.
     * @since 3.4
     */
    public FTPFile mdtmFile(String pathname) throws IOException {
<span class="nc bnc" id="L3555" title="All 2 branches missed.">        if (FTPReply.isPositiveCompletion(mdtm(pathname))) {</span>
<span class="nc" id="L3556">            String reply = getReplyStrings()[0].substring(4); // skip the return code (e.g. 213) and the space</span>
<span class="nc" id="L3557">            FTPFile file = new FTPFile();</span>
<span class="nc" id="L3558">            file.setName(pathname);</span>
<span class="nc" id="L3559">            file.setRawListing(reply);</span>
<span class="nc" id="L3560">            file.setTimestamp(MLSxEntryParser.parseGMTdateTime(reply));</span>
<span class="nc" id="L3561">            return file;</span>
        }
<span class="nc" id="L3563">        return null;</span>
    }


    /**
     * Issue the FTP MFMT command (not supported by all servers) which sets the last
     * modified time of a file.
     *
     * The timestamp should be in the form &lt;code&gt;YYYYMMDDhhmmss&lt;/code&gt;. It should also
     * be in GMT, but not all servers honour this.
     *
     * An FTP server would indicate its support of this feature by including &quot;MFMT&quot;
     * in its response to the FEAT command, which may be retrieved by FTPClient.features()
     *
     * @param pathname The file path for which last modified time is to be changed.
     * @param timeval The timestamp to set to, in &lt;code&gt;YYYYMMDDhhmmss&lt;/code&gt; format.
     * @return true if successfully set, false if not
     * @throws IOException if an I/O error occurs.
     * @since 2.2
     * @see &lt;a href=&quot;http://tools.ietf.org/html/draft-somers-ftp-mfxx-04&quot;&gt;http://tools.ietf.org/html/draft-somers-ftp-mfxx-04&lt;/a&gt;
     */
    public boolean setModificationTime(String pathname, String timeval) throws IOException {
<span class="nc" id="L3585">        return (FTPReply.isPositiveCompletion(mfmt(pathname, timeval)));</span>
    }


    /**
     * Set the internal buffer size for buffered data streams.
     *
     * @param bufSize The size of the buffer. Use a non-positive value to use the default.
     */
    public void setBufferSize(int bufSize) {
<span class="nc" id="L3595">        __bufferSize = bufSize;</span>
<span class="nc" id="L3596">    }</span>

    /**
     * Retrieve the current internal buffer size for buffered data streams.
     * @return The current buffer size.
     */
    public int getBufferSize() {
<span class="nc" id="L3603">        return __bufferSize;</span>
    }

    /**
     * Sets the value to be used for the data socket SO_SNDBUF option.
     * If the value is positive, the option will be set when the data socket has been created.
     *
     * @param bufSize The size of the buffer, zero or negative means the value is ignored.
      * @since 3.3
    */
    public void setSendDataSocketBufferSize(int bufSize) {
<span class="nc" id="L3614">        __sendDataSocketBufferSize = bufSize;</span>
<span class="nc" id="L3615">    }</span>

    /**
     * Retrieve the value to be used for the data socket SO_SNDBUF option.
     * @return The current buffer size.
     * @since 3.3
     */
    public int getSendDataSocketBufferSize() {
<span class="nc" id="L3623">        return __sendDataSocketBufferSize;</span>
    }

    /**
     * Sets the value to be used for the data socket SO_RCVBUF option.
     * If the value is positive, the option will be set when the data socket has been created.
     *
     * @param bufSize The size of the buffer, zero or negative means the value is ignored.
     * @since 3.3
     */
    public void setReceieveDataSocketBufferSize(int bufSize) {
<span class="nc" id="L3634">        __receiveDataSocketBufferSize = bufSize;</span>
<span class="nc" id="L3635">    }</span>

    /**
     * Retrieve the value to be used for the data socket SO_RCVBUF option.
     * @return The current buffer size.
     * @since 3.3
     */
    public int getReceiveDataSocketBufferSize() {
<span class="nc" id="L3643">        return __receiveDataSocketBufferSize;</span>
    }

    /**
     * Implementation of the {@link Configurable Configurable} interface.
     * In the case of this class, configuring merely makes the config object available for the
     * factory methods that construct parsers.
     * @param config {@link FTPClientConfig FTPClientConfig} object used to
     * provide non-standard configurations to the parser.
     * @since 1.4
     */
    @Override
    public void configure(FTPClientConfig config) {
<span class="nc" id="L3656">        this.__configuration = config;</span>
<span class="nc" id="L3657">    }</span>

    /**
     * You can set this to true if you would like to get hidden files when {@link #listFiles} too.
     * A &lt;code&gt;LIST -a&lt;/code&gt; will be issued to the ftp server.
     * It depends on your ftp server if you need to call this method, also dont expect to get rid
     * of hidden files if you call this method with &quot;false&quot;.
     *
     * @param listHiddenFiles true if hidden files should be listed
     * @since 2.0
     */
    public void setListHiddenFiles(boolean listHiddenFiles) {
<span class="nc" id="L3669">        this.__listHiddenFiles = listHiddenFiles;</span>
<span class="nc" id="L3670">    }</span>

    /**
     * @see #setListHiddenFiles(boolean)
     * @return the current state
     * @since 2.0
     */
    public boolean getListHiddenFiles() {
<span class="nc" id="L3678">        return this.__listHiddenFiles;</span>
    }

    /**
     * Whether should attempt to use EPSV with IPv4.
     * Default (if not set) is &lt;code&gt;false&lt;/code&gt;
     * @return true if should attempt EPSV
     * @since 2.2
     */
    public boolean isUseEPSVwithIPv4() {
<span class="nc" id="L3688">        return __useEPSVwithIPv4;</span>
    }


    /**
     * Set whether to use EPSV with IPv4.
     * Might be worth enabling in some circumstances.
     *
     * For example, when using IPv4 with NAT it
     * may work with some rare configurations.
     * E.g. if FTP server has a static PASV address (external network)
     * and the client is coming from another internal network.
     * In that case the data connection after PASV command would fail,
     * while EPSV would make the client succeed by taking just the port.
     *
     * @param selected value to set.
     * @since 2.2
     */
    public void setUseEPSVwithIPv4(boolean selected) {
<span class="nc" id="L3707">        this.__useEPSVwithIPv4 = selected;</span>
<span class="nc" id="L3708">    }</span>

    /**
     * Set the listener to be used when performing store/retrieve operations.
     * The default value (if not set) is {@code null}.
     *
     * @param listener to be used, may be {@code null} to disable
     * @since 3.0
     */
    public void setCopyStreamListener(CopyStreamListener listener){
<span class="nc" id="L3718">        __copyStreamListener = listener;</span>
<span class="nc" id="L3719">    }</span>

    /**
     * Obtain the currently active listener.
     *
     * @return the listener, may be {@code null}
     * @since 3.0
     */
    public CopyStreamListener getCopyStreamListener(){
<span class="nc" id="L3728">        return __copyStreamListener;</span>
    }

    /**
     * Set the time to wait between sending control connection keepalive messages
     * when processing file upload or download.
     *
     * @param controlIdle the wait (in secs) between keepalive messages. Zero (or less) disables.
     * @since 3.0
     * @see #setControlKeepAliveReplyTimeout(int)
     */
    public void setControlKeepAliveTimeout(long controlIdle){
<span class="nc" id="L3740">        __controlKeepAliveTimeout = controlIdle * 1000;</span>
<span class="nc" id="L3741">    }</span>

    /**
     * Get the time to wait between sending control connection keepalive messages.
     * @return the number of seconds between keepalive messages.
     * @since 3.0
     */
    public long getControlKeepAliveTimeout() {
<span class="nc" id="L3749">        return __controlKeepAliveTimeout / 1000;</span>
    }

    /**
     * Set how long to wait for control keep-alive message replies.
     *
     * @param timeout number of milliseconds to wait (defaults to 1000)
     * @since 3.0
     * @see #setControlKeepAliveTimeout(long)
     */
    public void setControlKeepAliveReplyTimeout(int timeout) {
<span class="nc" id="L3760">        __controlKeepAliveReplyTimeout = timeout;</span>
<span class="nc" id="L3761">    }</span>

    /**
     * Get how long to wait for control keep-alive message replies.
     * @return wait time in msec
     * @since 3.0
     */
    public int getControlKeepAliveReplyTimeout() {
<span class="nc" id="L3769">        return __controlKeepAliveReplyTimeout;</span>
    }

    /**
     * Enable or disable passive mode NAT workaround.
     * If enabled, a site-local PASV mode reply address will be replaced with the
     * remote host address to which the PASV mode request was sent
     * (unless that is also a site local address).
     * This gets around the problem that some NAT boxes may change the
     * reply.
     *
     * The default is true, i.e. site-local replies are replaced.
     * @param enabled true to enable replacing internal IP's in passive
     * mode.
     * @deprecated (3.6) use {@link #setPassiveNatWorkaroundStrategy(HostnameResolver)} instead
     */
    @Deprecated
    public void setPassiveNatWorkaround(boolean enabled) {
<span class="pc bpc" id="L3787" title="1 of 2 branches missed.">        if (enabled) {</span>
<span class="nc" id="L3788">            this.__passiveNatWorkaroundStrategy = new NatServerResolverImpl(this);</span>
        } else {
<span class="fc" id="L3790">            this.__passiveNatWorkaroundStrategy = null;</span>
        }
<span class="fc" id="L3792">    }</span>

    /**
     * Set the workaround strategy to replace the PASV mode reply addresses.
     * This gets around the problem that some NAT boxes may change the reply.
     *
     * The default implementation is {@code NatServerResolverImpl}, i.e. site-local
     * replies are replaced.
     * @param resolver strategy to replace internal IP's in passive mode
     * or null to disable the workaround (i.e. use PASV mode reply address.)
     * @since 3.6
     */
    public void setPassiveNatWorkaroundStrategy(HostnameResolver resolver) {
<span class="fc" id="L3805">        this.__passiveNatWorkaroundStrategy = resolver;</span>
<span class="fc" id="L3806">    }</span>

    /**
     * Strategy interface for updating host names received from FTP server
     * for passive NAT workaround.
     *
     * @since 3.6
     */
    public static interface HostnameResolver {
        String resolve(String hostname) throws UnknownHostException;
    }

    /**
     * Default strategy for passive NAT workaround (site-local
     * replies are replaced.)
     * @since 3.6
     */
    public static class NatServerResolverImpl implements HostnameResolver {
        private FTPClient client;

<span class="fc" id="L3826">        public NatServerResolverImpl(FTPClient client) {</span>
<span class="fc" id="L3827">            this.client = client;</span>
<span class="fc" id="L3828">        }</span>

        @Override
        public String resolve(String hostname) throws UnknownHostException {
<span class="fc" id="L3832">            String newHostname = hostname;</span>
<span class="fc" id="L3833">            InetAddress host = InetAddress.getByName(newHostname);</span>
            // reply is a local address, but target is not - assume NAT box changed the PASV reply
<span class="fc bfc" id="L3835" title="All 2 branches covered.">            if (host.isSiteLocalAddress()) {</span>
<span class="fc" id="L3836">                InetAddress remote = this.client.getRemoteAddress();</span>
<span class="pc bpc" id="L3837" title="1 of 2 branches missed.">                if (!remote.isSiteLocalAddress()){</span>
<span class="fc" id="L3838">                    newHostname = remote.getHostAddress();</span>
                }
            }
<span class="fc" id="L3841">            return newHostname;</span>
        }
    }

    private OutputStream getBufferedOutputStream(OutputStream outputStream) {
<span class="nc bnc" id="L3846" title="All 2 branches missed.">        if (__bufferSize &gt; 0) {</span>
<span class="nc" id="L3847">            return new BufferedOutputStream(outputStream, __bufferSize);</span>
        }
<span class="nc" id="L3849">        return new BufferedOutputStream(outputStream);</span>
    }

    private InputStream getBufferedInputStream(InputStream inputStream) {
<span class="nc bnc" id="L3853" title="All 2 branches missed.">        if (__bufferSize &gt; 0) {</span>
<span class="nc" id="L3854">            return new BufferedInputStream(inputStream, __bufferSize);</span>
        }
<span class="nc" id="L3856">        return new BufferedInputStream(inputStream);</span>
    }

    // @since 3.0
    private static class CSL implements CopyStreamListener {

        private final FTPClient parent;
        private final long idle;
        private final int currentSoTimeout;

<span class="nc" id="L3866">        private long time = System.currentTimeMillis();</span>
        private int notAcked;

<span class="nc" id="L3869">        CSL(FTPClient parent, long idleTime, int maxWait) throws SocketException {</span>
<span class="nc" id="L3870">            this.idle = idleTime;</span>
<span class="nc" id="L3871">            this.parent = parent;</span>
<span class="nc" id="L3872">            this.currentSoTimeout = parent.getSoTimeout();</span>
<span class="nc" id="L3873">            parent.setSoTimeout(maxWait);</span>
<span class="nc" id="L3874">        }</span>

        @Override
        public void bytesTransferred(CopyStreamEvent event) {
<span class="nc" id="L3878">            bytesTransferred(event.getTotalBytesTransferred(), event.getBytesTransferred(), event.getStreamSize());</span>
<span class="nc" id="L3879">        }</span>

        @Override
        public void bytesTransferred(long totalBytesTransferred,
                int bytesTransferred, long streamSize) {
<span class="nc" id="L3884">            long now = System.currentTimeMillis();</span>
<span class="nc bnc" id="L3885" title="All 2 branches missed.">            if (now - time &gt; idle) {</span>
                try {
<span class="nc" id="L3887">                    parent.__noop();</span>
<span class="nc" id="L3888">                } catch (SocketTimeoutException e) {</span>
<span class="nc" id="L3889">                    notAcked++;</span>
<span class="nc" id="L3890">                } catch (IOException e) {</span>
                    // Ignored
<span class="nc" id="L3892">                }</span>
<span class="nc" id="L3893">                time = now;</span>
            }
<span class="nc" id="L3895">        }</span>

        void cleanUp() throws IOException {
            try {
<span class="nc bnc" id="L3899" title="All 2 branches missed.">                while(notAcked-- &gt; 0) {</span>
<span class="nc" id="L3900">                    parent.__getReplyNoReport();</span>
                }
            } finally {
<span class="nc" id="L3903">                parent.setSoTimeout(currentSoTimeout);</span>
            }
<span class="nc" id="L3905">        }</span>

    }

    /**
     * Merge two copystream listeners, either or both of which may be null.
     *
     * @param local the listener used by this class, may be null
     * @return a merged listener or a single listener or null
     * @since 3.0
     */
    private CopyStreamListener __mergeListeners(CopyStreamListener local) {
<span class="nc bnc" id="L3917" title="All 2 branches missed.">        if (local == null) {</span>
<span class="nc" id="L3918">            return __copyStreamListener;</span>
        }
<span class="nc bnc" id="L3920" title="All 2 branches missed.">        if (__copyStreamListener == null) {</span>
<span class="nc" id="L3921">            return local;</span>
        }
        // Both are non-null
<span class="nc" id="L3924">        CopyStreamAdapter merged = new CopyStreamAdapter();</span>
<span class="nc" id="L3925">        merged.addCopyStreamListener(local);</span>
<span class="nc" id="L3926">        merged.addCopyStreamListener(__copyStreamListener);</span>
<span class="nc" id="L3927">        return merged;</span>
    }

    /**
     * Enables or disables automatic server encoding detection (only UTF-8 supported).
     * &lt;p&gt;
     * Does not affect existing connections; must be invoked before a connection is established.
     *
     * @param autodetect If true, automatic server encoding detection will be enabled.
     */
    public void setAutodetectUTF8(boolean autodetect)
    {
<span class="nc" id="L3939">        __autodetectEncoding = autodetect;</span>
<span class="nc" id="L3940">    }</span>

    /**
     * Tells if automatic server encoding detection is enabled or disabled.
     * @return true, if automatic server encoding detection is enabled.
     */
    public boolean getAutodetectUTF8()
    {
<span class="nc" id="L3948">        return __autodetectEncoding;</span>
    }

    // Method for use by unit test code only
    FTPFileEntryParser getEntryParser() {
<span class="fc" id="L3953">        return __entryParser;</span>
    }

    // DEPRECATED METHODS - for API compatibility only - DO NOT USE

    /**
     * @return the name
     * @throws IOException on error
     * @deprecated use {@link #getSystemType()} instead
     */
    @Deprecated
    public String getSystemName() throws IOException
    {
<span class="nc bnc" id="L3966" title="All 4 branches missed.">        if (__systemName == null &amp;&amp; FTPReply.isPositiveCompletion(syst())) {</span>
<span class="nc" id="L3967">            __systemName = _replyLines.get(_replyLines.size() - 1).substring(4);</span>
        }
<span class="nc" id="L3969">        return __systemName;</span>
    }
}

/* Emacs configuration
 * Local variables:        **
 * mode:             java  **
 * c-basic-offset:   4     **
 * indent-tabs-mode: nil   **
 * End:                    **
 */
/* kate: indent-width 4; replace-tabs on; */
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>